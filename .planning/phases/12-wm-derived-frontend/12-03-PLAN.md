---
phase: 12-wm-derived-frontend
plan: 03
type: execute
wave: 2
depends_on: ["12-01", "12-02"]
files_modified:
  - frontend/src/components/DeckGLMap.ts
  - frontend/src/services/country-geometry.ts
  - frontend/public/data/countries.geojson
autonomous: true

must_haves:
  truths:
    - "Globe renders in the center of the dashboard with CARTO dark-matter basemap tiles"
    - "Countries are colored by risk score (blue=low, gray=mid, red=high) from the API's CountryRiskSummary data"
    - "At least 3 additional map layers are toggleable via UI controls (ActiveForecastMarkers, GDELTEventHeatmap, ScenarioZones)"
    - "Clicking a country on the globe dispatches a 'country-selected' CustomEvent with the ISO code"
    - "Switching dark/light theme changes the basemap style and rebuilds layer colors"
  artifacts:
    - path: "frontend/src/components/DeckGLMap.ts"
      provides: "Globe component with 5 deck.gl layers"
      contains: "class DeckGLMap"
    - path: "frontend/src/services/country-geometry.ts"
      provides: "GeoJSON loader with ISO code normalization and hit testing"
      contains: "normalizeCode"
    - path: "frontend/public/data/countries.geojson"
      provides: "Country boundary polygons for choropleth"
  key_links:
    - from: "frontend/src/components/DeckGLMap.ts"
      to: "frontend/src/services/forecast-client.ts"
      via: "getCountries() for risk scores"
      pattern: "forecastClient"
    - from: "frontend/src/components/DeckGLMap.ts"
      to: "frontend/src/services/country-geometry.ts"
      via: "GeoJSON loading + normalizeCode"
      pattern: "country-geometry"
    - from: "frontend/src/components/DeckGLMap.ts"
      to: "maplibre-gl"
      via: "Map + MapboxOverlay"
      pattern: "maplibregl.Map"
---

<objective>
Build the deck.gl globe with all 5 map layers: ForecastRiskChoropleth, ActiveForecastMarkers, KnowledgeGraphArcs, GDELTEventHeatmap, and ScenarioZones. This is the visual centerpiece of the dashboard.

Purpose: The globe is the primary interaction surface (SC-1: "deck.gl globe with ForecastRiskChoropleth layer"). Clicking countries opens Country Brief pages, hovering shows tooltips. All layers are toggleable.

Output: DeckGLMap component rendering in the center grid area, country-geometry service for GeoJSON handling, and a countries.geojson file for choropleth rendering.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/12-wm-derived-frontend/12-CONTEXT.md
@.planning/phases/12-wm-derived-frontend/12-RESEARCH.md
@.planning/phases/12-wm-derived-frontend/12-01-SUMMARY.md
@.planning/phases/12-wm-derived-frontend/12-02-SUMMARY.md

# WM source files for reference:
@/home/kondraki/personal/worldmonitor/src/components/DeckGLMap.ts
@/home/kondraki/personal/worldmonitor/src/services/country-geometry.ts

# TypeScript types and service client:
@frontend/src/types/api.ts
@frontend/src/services/forecast-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Country geometry service + GeoJSON data file</name>
  <files>
    frontend/src/services/country-geometry.ts
    frontend/public/data/countries.geojson
  </files>
  <action>
    **countries.geojson**: Download Natural Earth 110m admin-0 countries GeoJSON. Use the simplified version (~500KB) suitable for country-level choropleth. Fetch from a CDN or generate from Natural Earth data. The file MUST contain ISO 3166-1 Alpha-2 codes in feature properties (check for `ISO_A2`, `ISO3166-1-Alpha-2`, or similar).

    If downloading is problematic, create a minimal placeholder GeoJSON with a few key countries (SY, UA, MM, IR, TW, SD, KP, VE) using approximate boundary polygons. The important thing is the structure -- real boundaries can be swapped in later.

    The recommended approach: `curl -o frontend/public/data/countries.geojson "https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json"` and convert TopoJSON to GeoJSON, OR use a direct GeoJSON source like `https://raw.githubusercontent.com/datasets/geo-countries/master/data/countries.geojson`.

    If the file is very large (>2MB), consider using the 110m resolution Natural Earth simplified version.

    **country-geometry.ts**: Read `/home/kondraki/personal/worldmonitor/src/services/country-geometry.ts` (303 lines). Adapt:

    **KEEP:**
    - normalizeCode(feature) function: extracts ISO code from various property names (ISO_A2, ISO3166-1-Alpha-2, iso_a2, etc.)
    - GeoJSON loading: fetch('/data/countries.geojson'), parse, build lookup maps
    - Country centroid calculation (for marker placement)
    - ISO-to-feature lookup map (Map<string, GeoJSON.Feature>)

    **REMOVE:**
    - WM-specific country metadata (population, GDP, etc.)
    - Tauri cache path
    - WM-specific country list management

    **ADD:**
    - getCentroid(iso: string): [number, number] | null -- returns lat/lon center of country for forecast marker placement
    - getFeatureByIso(iso: string): GeoJSON.Feature | null
    - isLoaded(): boolean

    **Export:**
    - CountryGeometryService class
    - Module-level singleton: `export const countryGeometry = new CountryGeometryService()`
    - Call `countryGeometry.load()` during app initialization

    GeoJSON types: Use the `GeoJSON` namespace from the GeoJSON spec. Add a type declaration if needed:
    ```typescript
    declare namespace GeoJSON {
      interface FeatureCollection { type: 'FeatureCollection'; features: Feature[]; }
      interface Feature { type: 'Feature'; properties: Record<string, unknown> | null; geometry: Geometry; }
      // etc.
    }
    ```
    Or use the built-in DOM types if available.
  </action>
  <verify>
    `cd frontend && npx tsc --noEmit` passes.
    `ls frontend/public/data/countries.geojson` exists.
  </verify>
  <done>
    country-geometry.ts normalizes ISO codes across GeoJSON property variants.
    GeoJSON file exists at public/data/countries.geojson.
    Centroid and feature lookup work for any ISO-2 code.
  </done>
</task>

<task type="auto">
  <name>Task 2: DeckGLMap component with 5 layers</name>
  <files>frontend/src/components/DeckGLMap.ts</files>
  <action>
    Create the DeckGLMap component. This is NOT a Panel subclass -- it's a standalone map component that occupies the center grid area. Read WM's DeckGLMap.ts for patterns but DO NOT copy the 4258-line file. Build a focused ~400-500 line version.

    **Initialization sequence (from WM, simplified):**
    1. Create maplibre-gl Map with CARTO dark-matter basemap:
       ```
       style: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json'
       center: [30, 20], zoom: 1.8
       renderWorldCopies: false
       ```
    2. On map 'load' event, create MapboxOverlay:
       ```
       new MapboxOverlay({ interleaved: true, layers: this.buildLayers(), getTooltip, onClick, pickingRadius: 10 })
       ```
    3. Add overlay as map control

    **5 layers (implement all 5, data can be empty/mock for some):**

    1. **ForecastRiskChoropleth** (GeoJsonLayer): Colors countries by risk score. Data: countries.geojson + risk scores from API. getFillColor: blue-to-red diverging scale using risk_score (0.0 -> blue [70,130,180], 0.5 -> gray [128,128,128], 1.0 -> red [220,50,50]). Use d3.interpolateRdBu or manual linear interpolation. Pickable. updateTriggers keyed on risk score map size + update timestamp.

    2. **ActiveForecastMarkers** (ScatterplotLayer): Points at country centroids for countries with active forecasts. Data: country centroids from countryGeometry.getCentroid(). getRadius: 8 + probability * 20 (larger = more likely). getFillColor: red shades based on probability. Pickable.

    3. **KnowledgeGraphArcs** (ArcLayer): Actor-to-actor arcs. Data: empty initially, populated when a country is selected (from forecast scenario entities). getSourcePosition/getTargetPosition from entity pair centroids. getSourceColor/getTargetColor: accent colors. Visibility: only when selectedCountry is set.

    4. **GDELTEventHeatmap** (HeatmapLayer from @deck.gl/aggregation-layers): Heat density of recent events. Data: empty array initially (no GDELT endpoint yet). getPosition: [lon, lat]. getWeight: 1. radiusPixels: 30. intensity: 1. threshold: 0.03. Accepts a time range filter prop.

    5. **ScenarioZones** (GeoJsonLayer): Highlights countries mentioned in selected forecast's scenario entities. Data: filtered countries.geojson features for countries in the selected forecast's entities list. getFillColor: accent with low opacity [0, 212, 255, 60]. Visibility: only when selectedForecast is set.

    **Layer toggle UI:**
    Create a floating layer control panel (positioned top-right of map container). Each layer has a checkbox + label. Toggling a checkbox rebuilds layers with that layer included/excluded.

    **Event handling:**
    - onClick for choropleth: dispatch `country-selected` CustomEvent with `{ iso: normalizedCode }`. Also set `ctx.selectedCountry`.
    - onHover for choropleth: show tooltip with country name + risk score
    - Listen for `theme-changed` event: swap basemap style (dark-matter vs positron/voyager), rebuild all layers with updated colors

    **Public methods:**
    - `updateRiskScores(scores: Map<string, number>)`: Update choropleth colors
    - `updateForecasts(forecasts: ForecastResponse[])`: Update markers from forecast data
    - `setSelectedCountry(iso: string | null)`: Show/hide KnowledgeGraphArcs
    - `setSelectedForecast(forecast: ForecastResponse | null)`: Show/hide ScenarioZones
    - `destroy()`: Clean up map + overlay

    **CARTO basemap URLs:**
    - Dark: `https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json`
    - Light: `https://basemaps.cartocdn.com/gl/positron-gl-style/style.json`

    Add layer toggle control styles to panels.css (floating panel with checkboxes).
  </action>
  <verify>
    `cd frontend && npx tsc --noEmit` passes.
    `cd frontend && npx vite build` succeeds (deck.gl manual chunk produced).
  </verify>
  <done>
    DeckGLMap renders globe with CARTO basemap and 5 deck.gl layers.
    Choropleth colors countries by risk score (blue-gray-red diverging).
    Layer toggle UI controls visibility of each layer.
    Country click dispatches event, hover shows tooltip.
    Theme switch changes basemap + rebuilds layers.
  </done>
</task>

</tasks>

<verification>
- `cd frontend && npx tsc --noEmit` passes
- `cd frontend && npx vite build` succeeds
- Globe renders in browser with dark basemap tiles
- Countries visible with choropleth coloring
- Layer toggle panel visible with 5 checkboxes
- Theme switch changes basemap style
</verification>

<success_criteria>
- Globe renders with CARTO dark-matter basemap
- ForecastRiskChoropleth colors countries by risk score
- At least 3 additional layers toggleable via UI
- Country click dispatches selection event
- Theme switch rebuilds basemap + layers
</success_criteria>

<output>
After completion, create `.planning/phases/12-wm-derived-frontend/12-03-SUMMARY.md`
</output>
