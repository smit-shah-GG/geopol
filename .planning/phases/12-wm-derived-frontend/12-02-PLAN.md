---
phase: 12-wm-derived-frontend
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - frontend/src/utils/circuit-breaker.ts
  - frontend/src/services/forecast-client.ts
autonomous: true

must_haves:
  truths:
    - "ForecastServiceClient.getTopForecasts() returns data from the FastAPI backend (or mock fixtures)"
    - "Circuit breaker returns cached data when the API is unreachable instead of crashing"
    - "Duplicate in-flight requests to the same endpoint are deduplicated (only one fetch fires)"
    - "Each API method reports data state: live, cached, or unavailable"
  artifacts:
    - path: "frontend/src/utils/circuit-breaker.ts"
      provides: "CircuitBreaker class with failure counting, cooldown, TTL cache, stale-while-revalidate"
      contains: "class CircuitBreaker"
    - path: "frontend/src/services/forecast-client.ts"
      provides: "ForecastServiceClient consuming all Geopol API endpoints"
      exports: ["ForecastServiceClient"]
  key_links:
    - from: "frontend/src/services/forecast-client.ts"
      to: "frontend/src/utils/circuit-breaker.ts"
      via: "CircuitBreaker wrapping fetch calls"
      pattern: "CircuitBreaker"
    - from: "frontend/src/services/forecast-client.ts"
      to: "/api/v1/"
      via: "fetch() to FastAPI endpoints"
      pattern: "fetch.*api/v1"
---

<objective>
Build the ForecastServiceClient and CircuitBreaker -- the service layer that every panel uses to fetch data from the Geopol FastAPI backend. The circuit breaker provides resilience (stale data on failure, not a broken UI), and the client provides typed methods for every API endpoint.

Purpose: All panels (Plans 03-07) depend on this service layer. Without it, panels can't fetch data. The circuit breaker pattern is critical for FE-08 (API failures show stale data, not errors).

Output: Two files -- `circuit-breaker.ts` and `forecast-client.ts` -- that provide typed, resilient API access.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/12-wm-derived-frontend/12-CONTEXT.md
@.planning/phases/12-wm-derived-frontend/12-RESEARCH.md
@.planning/phases/12-wm-derived-frontend/12-01-SUMMARY.md

# WM source for circuit breaker:
@/home/kondraki/personal/worldmonitor/src/utils/circuit-breaker.ts

# API endpoints to consume (understand the contract):
@src/api/routes/v1/forecasts.py
@src/api/routes/v1/countries.py
@src/api/routes/v1/health.py

# TypeScript types (created in Plan 01):
@frontend/src/types/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: CircuitBreaker class</name>
  <files>frontend/src/utils/circuit-breaker.ts</files>
  <action>
    Read `/home/kondraki/personal/worldmonitor/src/utils/circuit-breaker.ts` (279 lines). Adapt for Geopol:

    **REMOVE:**
    - IndexedDB persistent cache (persistCache option, _loadFromIdb, _saveToIdb) -- unnecessary for single-API client
    - Tauri offline detection (`navigator.onLine` / Tauri bridge checks)
    - Beacon API for offline queue

    **KEEP:**
    - CircuitState interface (failures, cooldownUntil, lastError)
    - CacheEntry<T> interface (data, timestamp)
    - BreakerDataMode type: 'live' | 'cached' | 'unavailable'
    - BreakerDataState interface (mode, timestamp, offline)
    - CircuitBreakerOptions interface (name, maxFailures, cooldownMs, cacheTtlMs)
    - Core execute() method: attempt fetch -> on success, cache result + reset failures -> on failure, increment failures, check if over threshold -> if circuit open (in cooldown), return cached data if available, or fallback
    - TTL-based in-memory cache with stale-while-revalidate
    - getDataState() method returning current mode

    **ADD:**
    - createCircuitBreaker<T>() factory function for convenience

    The execute signature should be:
    ```typescript
    async execute(fetchFn: () => Promise<T>, fallback: T): Promise<T>
    ```
    Where `fallback` is returned when both fetch and cache fail.

    Export: CircuitBreaker class, createCircuitBreaker factory, BreakerDataMode type, BreakerDataState interface, CircuitBreakerOptions interface.
  </action>
  <verify>`cd frontend && npx tsc --noEmit` passes with circuit-breaker.ts included.</verify>
  <done>CircuitBreaker class handles failure counting, cooldown periods, TTL cache, and stale-while-revalidate. No IndexedDB, no Tauri, no offline queue.</done>
</task>

<task type="auto">
  <name>Task 2: ForecastServiceClient</name>
  <files>frontend/src/services/forecast-client.ts</files>
  <action>
    Create ForecastServiceClient class consuming ALL Geopol API endpoints. Use the circuit breaker for resilience and in-flight deduplication for efficiency.

    **Configuration:**
    - API_BASE from `import.meta.env.VITE_API_BASE` or default `'/api/v1'` (Vite proxy handles the rest)
    - API_KEY from `import.meta.env.VITE_API_KEY` or empty string

    **Circuit breakers (one per endpoint group):**
    - forecastBreaker: maxFailures=2, cooldownMs=30000, cacheTtlMs=60000
    - countryBreaker: maxFailures=2, cooldownMs=30000, cacheTtlMs=120000
    - healthBreaker: maxFailures=3, cooldownMs=15000, cacheTtlMs=30000

    **In-flight deduplication:**
    - Private `inFlight: Map<string, Promise<unknown>>` map
    - Private `dedup<T>(key, fn)` method: if key exists in map, return existing promise; else create new promise, store in map, remove on settle

    **Public methods (typed, matching API routes):**
    1. `getTopForecasts(limit?: number): Promise<ForecastResponse[]>` -- GET /forecasts/top?limit=N
    2. `getForecastsByCountry(iso: string, cursor?: string, limit?: number): Promise<PaginatedResponse<ForecastResponse>>` -- GET /forecasts/country/{iso}
    3. `getForecastById(id: string): Promise<ForecastResponse | null>` -- GET /forecasts/{id}
    4. `getCountries(): Promise<CountryRiskSummary[]>` -- GET /countries
    5. `getCountryRisk(iso: string): Promise<CountryRiskSummary | null>` -- GET /countries/{iso}
    6. `getHealth(): Promise<HealthResponse>` -- GET /health (no API key required)
    7. `createForecast(question: string, countryIso: string, horizonDays?: number): Promise<ForecastResponse>` -- POST /forecasts

    **Private fetch helper:**
    ```typescript
    private async fetchJson<T>(path: string, options?: RequestInit): Promise<T>
    ```
    - Builds full URL from API_BASE + path
    - Adds `X-API-Key` header (except for /health)
    - Adds `Content-Type: application/json` for POST
    - Throws on non-2xx status
    - Returns parsed JSON

    **Data state tracking:**
    - `getDataState(endpoint: string): BreakerDataState` method that exposes the circuit breaker's data state per endpoint group
    - Panels use this to show the data badge (live/cached/unavailable)

    **Singleton export:**
    - Export both the class and a module-level singleton instance: `export const forecastClient = new ForecastServiceClient()`
    - Panels import the singleton directly

    **Design note -- FE-01 DataLoaderManager:** The ForecastServiceClient + CircuitBreaker architecture supersedes the originally-specified DataLoaderManager from FE-01. The circuit breaker's failure counting + TTL cache + stale-while-revalidate provides the same resilience guarantees. The in-flight deduplication map (`this.inFlight`) handles request deduplication. A separate DataLoaderManager class would be redundant wrapping. If FE-01 is later audited, point to ForecastServiceClient as the implementation that fulfills DataLoaderManager's intent.

    Handle the health endpoint specially: no API key header, separate circuit breaker with more lenient thresholds.
    Handle 404 for getForecastById and getCountryRisk: return null instead of throwing.
  </action>
  <verify>
    `cd frontend && npx tsc --noEmit` passes.
    Verify ForecastServiceClient has all 7 public methods with correct return types.
  </verify>
  <done>
    ForecastServiceClient provides typed methods for all 7 Geopol API endpoints.
    Circuit breaker wraps every fetch with failure counting + cached fallback.
    In-flight deduplication prevents duplicate requests.
    Data state (live/cached/unavailable) is queryable per endpoint group.
    Singleton instance exported for panel consumption.
    FE-01 DataLoaderManager requirement fulfilled by this architecture (documented in action).
  </done>
</task>

</tasks>

<verification>
- `cd frontend && npx tsc --noEmit` passes
- circuit-breaker.ts exports CircuitBreaker class and factory
- forecast-client.ts exports ForecastServiceClient and singleton
- All 7 API methods present with correct TypeScript signatures
- No IndexedDB, Tauri, or offline queue code
</verification>

<success_criteria>
- CircuitBreaker handles: live fetch, cache fallback, cooldown, stale-while-revalidate
- ForecastServiceClient provides typed access to all Geopol API endpoints
- Every fetch is wrapped in circuit breaker + deduplication
- Data state is queryable for UI indicators
- FE-01 DataLoaderManager requirement addressed via ForecastServiceClient architecture
</success_criteria>

<output>
After completion, create `.planning/phases/12-wm-derived-frontend/12-02-SUMMARY.md`
</output>
