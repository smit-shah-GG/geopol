---
phase: 12-wm-derived-frontend
plan: 04
type: execute
wave: 3
depends_on: ["12-01", "12-02"]
files_modified:
  - frontend/src/components/ForecastPanel.ts
  - frontend/src/components/RiskIndexPanel.ts
  - frontend/src/components/EventTimelinePanel.ts
  - frontend/src/components/EnsembleBreakdownPanel.ts
  - frontend/src/components/SystemHealthPanel.ts
  - frontend/src/components/CalibrationPanel.ts
autonomous: true

must_haves:
  truths:
    - "ForecastPanel shows top N forecasts sorted by probability with question text, probability bar, country code, confidence, scenario count, and timestamp"
    - "RiskIndexPanel displays per-country aggregate risk scores with trend arrows (rising/stable/falling)"
    - "SystemHealthPanel shows 8 subsystem statuses with healthy/unhealthy indicators"
    - "CalibrationPanel renders a reliability diagram (predicted vs observed dots along a perfect-calibration diagonal) AND a time-series sparkline showing prediction accuracy over time"
  artifacts:
    - path: "frontend/src/components/ForecastPanel.ts"
      provides: "Top N active forecasts panel"
      contains: "class ForecastPanel"
    - path: "frontend/src/components/RiskIndexPanel.ts"
      provides: "Country risk index panel (CII-derived)"
      contains: "class RiskIndexPanel"
    - path: "frontend/src/components/CalibrationPanel.ts"
      provides: "Reliability diagram + Brier decomposition + track record sparkline"
      contains: "class CalibrationPanel"
    - path: "frontend/src/components/SystemHealthPanel.ts"
      provides: "Subsystem health display"
      contains: "class SystemHealthPanel"
  key_links:
    - from: "frontend/src/components/ForecastPanel.ts"
      to: "frontend/src/services/forecast-client.ts"
      via: "forecastClient.getTopForecasts()"
      pattern: "forecastClient"
    - from: "frontend/src/components/RiskIndexPanel.ts"
      to: "frontend/src/services/forecast-client.ts"
      via: "forecastClient.getCountries()"
      pattern: "forecastClient"
    - from: "frontend/src/components/ForecastPanel.ts"
      to: "ScenarioExplorer"
      via: "dispatches 'forecast-selected' CustomEvent on click"
      pattern: "forecast-selected"
---

<objective>
Build all 6 dashboard panels: ForecastPanel, RiskIndexPanel, EventTimelinePanel, EnsembleBreakdownPanel, SystemHealthPanel, and CalibrationPanel. Each extends the Panel base class and renders data from the ForecastServiceClient.

Purpose: These panels populate the dashboard grid around the globe (FE-03 + FE-08). They consume API data and provide the data-dense analyst experience specified in CONTEXT.md.

Output: 6 panel components, each fetching data and rendering content with the intelligence/analyst aesthetic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/12-wm-derived-frontend/12-CONTEXT.md
@.planning/phases/12-wm-derived-frontend/12-RESEARCH.md
@.planning/phases/12-wm-derived-frontend/12-01-SUMMARY.md
@.planning/phases/12-wm-derived-frontend/12-02-SUMMARY.md

# WM reference panels for patterns:
@/home/kondraki/personal/worldmonitor/src/components/CIIPanel.ts

# TypeScript types and service client:
@frontend/src/types/api.ts
@frontend/src/services/forecast-client.ts
@frontend/src/components/Panel.ts
@frontend/src/utils/dom-utils.ts
@frontend/src/utils/theme-colors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: ForecastPanel + RiskIndexPanel + EventTimelinePanel</name>
  <files>
    frontend/src/components/ForecastPanel.ts
    frontend/src/components/RiskIndexPanel.ts
    frontend/src/components/EventTimelinePanel.ts
  </files>
  <action>
    All three panels extend the Panel base class from Plan 01. All use h() for DOM construction. All fetch data via the forecastClient singleton from Plan 02.

    **Dual API pattern -- ALL panels must expose BOTH methods:**
    - `refresh()`: Self-fetch method. Panel calls forecastClient internally, manages its own loading/error states. Used by RefreshScheduler for periodic updates.
    - `update(data: T)`: External data injection. Accepts pre-fetched data from main.ts wiring. Skips the fetch, goes straight to rendering. Used by main.ts for initial load and coordinated updates where main.ts fetches once and distributes to multiple consumers.

    Both methods must produce identical rendered output for the same data. The difference is only in who fetches.

    **ForecastPanel** (~120-150 lines):
    - Constructor: `super({ id: 'forecasts', title: 'ACTIVE FORECASTS', showCount: true })`
    - Public `refresh()` method: calls `forecastClient.getTopForecasts(10)`, handles loading/error states via Panel base methods, then calls internal render
    - Public `update(forecasts: ForecastResponse[])` method: accepts pre-fetched forecast data, calls internal render directly
    - Private `renderForecasts(forecasts: ForecastResponse[])`: shared rendering logic
    - Renders each forecast as a card row:
      - Question text (truncated to ~100 chars)
      - Probability bar: horizontal bar colored by severity (critical >0.8, high >0.6, elevated >0.4, normal >0.2, low <=0.2), width = probability * 100%
      - Probability badge: percentage value in monospace
      - Country flag emoji (derived from ISO code) + country code
      - Confidence level as text badge
      - Scenario count (e.g. "3 scenarios")
      - Last-updated timestamp (relative: "2h ago", "1d ago")
    - Sorted by probability descending (API already sorts this way)
    - onClick for each card: dispatch `forecast-selected` CustomEvent with `{ detail: { forecast } }` -- ScenarioExplorer (Plan 05) will listen for this
    - Set data badge from circuit breaker state
    - Use `setCount(forecasts.length)` to show count in header

    **RiskIndexPanel** (~100-130 lines):
    - Constructor: `super({ id: 'risk-index', title: 'RISK INDEX', showCount: true })`
    - Public `refresh()`: calls `forecastClient.getCountries()`, handles loading/error, calls internal render
    - Public `update(countries: CountryRiskSummary[])`: accepts pre-fetched data, calls internal render
    - Private `renderCountries(countries: CountryRiskSummary[])`: shared rendering logic
    - Renders each country as a compact row (see RESEARCH.md RiskIndexPanel example):
      - Country flag emoji + ISO code
      - Risk score (0-100, color-coded by severity thresholds)
      - Trend arrow: rising (red up arrow), stable (gray right arrow), falling (green down arrow)
      - Top question text (truncated)
    - onClick for each row: dispatch `country-selected` CustomEvent with `{ detail: { iso } }`
    - Sorted by risk_score descending

    **EventTimelinePanel** (~100-120 lines):
    - Constructor: `super({ id: 'event-timeline', title: 'GDELT EVENTS', showCount: true })`
    - Public `refresh()`: no dedicated API endpoint yet, renders mock data
    - Public `update(events: unknown[])`: placeholder for future event data injection
    - This panel currently has no dedicated API endpoint for raw GDELT events. For now:
      - Show a placeholder message: "GDELT event feed connects when ingest daemon is running"
      - Render a mock timeline with 5-6 hardcoded example events showing the layout:
        - Timestamp (relative), event description, CAMEO code badge, Goldstein scale indicator, country code
      - The mock data demonstrates the expected format so it's ready when a real events endpoint is added
    - Style as a scrollable list with alternating row backgrounds
    - Each event row: monospace timestamp | brief description | colored CAMEO badge

    Add relevant CSS to panels.css:
    - `.forecast-card`: flex row, hover effect, cursor pointer
    - `.probability-bar`: height 4px, background gradient, border-radius
    - `.risk-row`: flex row with gap, hover effect
    - `.risk-score`: monospace, tabular-nums, sized by score value
    - `.trend-rising/.trend-stable/.trend-falling`: colored arrows
    - `.event-row`: monospace, alternating bg
    - `.cameo-badge`: small rounded badge with category color
  </action>
  <verify>
    `cd frontend && npx tsc --noEmit` passes.
    All three panel classes export correctly and extend Panel.
    Each panel has both `refresh()` and `update(data)` public methods.
  </verify>
  <done>
    ForecastPanel renders top N forecasts with probability bars, country codes, and click-to-select. Has refresh() and update(forecasts) methods.
    RiskIndexPanel renders country risk scores with trend arrows. Has refresh() and update(countries) methods.
    EventTimelinePanel shows mock event timeline layout. Has refresh() and update(events) methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: EnsembleBreakdownPanel + SystemHealthPanel + CalibrationPanel</name>
  <files>
    frontend/src/components/EnsembleBreakdownPanel.ts
    frontend/src/components/SystemHealthPanel.ts
    frontend/src/components/CalibrationPanel.ts
  </files>
  <action>
    **Dual API pattern applies to ALL panels here too** -- each exposes both `refresh()` and `update(data)`.

    **EnsembleBreakdownPanel** (~80-100 lines):
    - Constructor: `super({ id: 'ensemble', title: 'ENSEMBLE WEIGHTS' })`
    - Displays LLM vs TKG contribution for the selected forecast (or aggregate view)
    - Public `refresh()`: no-op (this panel is update-driven, not poll-driven)
    - Public `update(forecast: ForecastResponse)`:
      - Shows ensemble_info.llm_probability and ensemble_info.tkg_probability as horizontal stacked bar
      - Shows weights breakdown (e.g. "LLM: 60% | TKG: 40%")
      - Shows temperature_applied value
      - Use accent colors: LLM = blue (#3388ff), TKG = orange (#ff8800)
    - When no forecast selected: show aggregate view text "Select a forecast to see ensemble breakdown"
    - Simple horizontal bar chart rendered with h() + inline width styles (no D3 needed)

    **SystemHealthPanel** (~100-120 lines):
    - Constructor: `super({ id: 'system-health', title: 'SYSTEM HEALTH' })`
    - Public `refresh()`: calls `forecastClient.getHealth()`, handles loading/error, calls internal render
    - Public `update(health: HealthResponse)`: accepts pre-fetched health data, calls internal render
    - Private `renderHealth(health: HealthResponse)`: shared rendering logic
    - Renders aggregate status badge: "HEALTHY" (green), "DEGRADED" (yellow), "UNHEALTHY" (red)
    - Lists all 8 subsystems with:
      - Status dot: green circle (healthy) or red circle (unhealthy)
      - Subsystem name
      - Detail text (from SubsystemStatus.detail)
      - Checked_at timestamp (relative)
    - The health endpoint is public (no API key needed)
    - Set data badge from circuit breaker state

    **CalibrationPanel** (~200-250 lines):
    - Constructor: `super({ id: 'calibration', title: 'CALIBRATION', showCount: true })`
    - Public `refresh()`: no-op (update-driven from selected forecast or aggregate data)
    - Public `update(calibrations: CalibrationDTO[])`: accepts calibration data and re-renders all three sections
    - Renders THREE visualizations:

    1. **Reliability diagram** (SVG, ~300x300px):
       - X-axis: predicted probability (0.0 to 1.0)
       - Y-axis: observed frequency (0.0 to 1.0)
       - Dashed diagonal line: perfect calibration reference
       - Scatter dots: one per calibration bin, positioned at (predicted, observed), radius proportional to sqrt(sample_size)
       - Colors: accent primary for dots, ghost for diagonal
       - Render using raw SVG element creation (createElementNS), NOT d3 -- simple enough to hand-roll
       - See RESEARCH.md "Reliability Diagram" code example for the pattern

    2. **Brier score decomposition** (text table):
       - Category | Brier Score | Sample Size
       - One row per CalibrationDTO from the selected forecast or aggregate data
       - Brier score color-coded: <0.1 green (excellent), <0.25 yellow (good), >=0.25 red (poor)

    3. **Prediction track record over time** (SVG sparkline, ~300x80px):
       - FE-08 requires "prediction track record over time"
       - X-axis: time (date labels at start/end), Y-axis: accuracy metric (0-1)
       - Render as a simple SVG polyline sparkline showing Brier score or accuracy over time
       - When data is insufficient (< 3 data points): show a placeholder SVG with dashed horizontal line at 0.5 and text "Track record populates as predictions resolve"
       - When calibration data accumulates: plot historical_accuracy values from CalibrationDTO entries as a time-series line
       - Use accent-secondary color for the line, subtle grid lines
       - Keep it compact -- this is a sparkline, not a full chart. ~300px wide, ~80px tall

    - When no calibration data: show placeholder "Calibration data populates as predictions resolve"
    - Use `setCount(calibrations.length)` to show number of categories

    Add CSS to panels.css:
    - `.ensemble-bar`: horizontal stacked bar
    - `.health-status-badge`: rounded badge with status color
    - `.health-subsystem`: flex row with status dot
    - `.status-dot`: 8px circle
    - `.reliability-diagram svg`: responsive width
    - `.brier-table`: monospace table with zebra striping
    - `.track-record-sparkline`: compact SVG container, margin-top
  </action>
  <verify>
    `cd frontend && npx tsc --noEmit` passes.
    All three panel classes export correctly and extend Panel.
    Each panel has both `refresh()` and `update(data)` public methods.
    CalibrationPanel renders 3 sections: reliability diagram, Brier table, track record sparkline.
  </verify>
  <done>
    EnsembleBreakdownPanel shows LLM vs TKG weights as stacked bar. Has refresh() (no-op) and update(forecast) methods.
    SystemHealthPanel shows 8 subsystem statuses with colored dots. Has refresh() and update(health) methods.
    CalibrationPanel renders reliability diagram SVG + Brier score table + prediction track record sparkline. Has refresh() (no-op) and update(calibrations) methods.
    All panels follow dual API pattern: refresh() for self-fetch, update(data) for external injection.
  </done>
</task>

</tasks>

<verification>
- `cd frontend && npx tsc --noEmit` passes
- All 6 panel classes extend Panel and export correctly
- All 6 panels expose both refresh() and update(data) public methods
- ForecastPanel dispatches 'forecast-selected' on click
- RiskIndexPanel dispatches 'country-selected' on click
- CalibrationPanel creates SVG reliability diagram + track record sparkline
- SystemHealthPanel renders 8 subsystem rows
</verification>

<success_criteria>
- 6 panels implemented covering FE-03 (5 dashboard panels) + FE-08 (CalibrationPanel with track record)
- Each panel has dual API: refresh() for scheduler, update(data) for main.ts wiring
- Each panel shows loading/error states via Panel base class
- Data badges reflect circuit breaker state (live/cached/unavailable)
- CalibrationPanel includes prediction track record sparkline (FE-08 requirement)
- Intelligence/analyst aesthetic consistent across all panels
</success_criteria>

<output>
After completion, create `.planning/phases/12-wm-derived-frontend/12-04-SUMMARY.md`
</output>
