# Phase 2 Plan 3: Graph Query Interface

## Goal
Build efficient query interface for temporal knowledge graph with semantic search capabilities

## Context
- NetworkX graph with temporal edges from Plan 02-01
- RotatE embeddings in Qdrant from Plan 02-02
- Need sub-10ms query latency for forecasting

## Approach
Create unified query API combining graph traversal, vector similarity, and temporal filtering

## Plan

### Task 1: Query Parser and Validator
**Goal**: Parse and validate user queries into structured format

**Steps**:
1. Define query schema (entities, relations, time windows, constraints)
2. Implement natural language query parser for common patterns
3. Add query validation with helpful error messages
4. Create query plan optimizer for complex queries
5. Support both exact match and semantic similarity modes

**Verify**:
- Parser handles entity pairs, time ranges, and relation types
- Invalid queries return clear error messages
- Query plans minimize graph traversal

### Task 2: Graph Traversal Engine
**Goal**: Efficient subgraph extraction with temporal constraints

**Steps**:
1. Implement k-hop neighborhood search with time bounds
2. Add bilateral relation finder for actor pairs
3. Create temporal path finding (events leading to outcome)
4. Implement pattern matching for event sequences
5. Add result ranking by confidence and recency

**Verify**:
- 2-hop search completes in < 5ms for dense nodes
- Temporal paths respect chronological ordering
- Pattern matching finds known sequences correctly

### Task 3: Vector Similarity Search
**Goal**: Semantic search using Qdrant embeddings

**Steps**:
1. Implement entity search by semantic similarity
2. Add relation type similarity search
3. Create hybrid search combining graph and vectors
4. Implement query expansion using similar entities
5. Add re-ranking based on temporal relevance

**Verify**:
- Semantic search returns relevant entities
- Hybrid search improves recall by >30%
- Re-ranking prioritizes recent events

### Task 4: Temporal Filtering and Aggregation
**Goal**: Time-aware query processing and aggregation

**Steps**:
1. Implement time window filtering at query time
2. Add temporal aggregation (daily, weekly, monthly)
3. Create sliding window analysis for trends
4. Implement decay functions for recency weighting
5. Add temporal co-occurrence detection

**Verify**:
- Time filtering reduces result set correctly
- Aggregations preserve event counts
- Trends detected match manual inspection

### Task 5: Result Formatting and Explanation
**Goal**: Generate interpretable results with reasoning paths

**Steps**:
1. Create result data structures with provenance
2. Implement explanation generation for predictions
3. Add confidence score calculation with components
4. Create JSON and human-readable output formats
5. Include source events and reasoning chains

**Verify**:
- Results include full reasoning paths
- Confidence scores are calibrated [0,1]
- Explanations reference specific events

### Task 6: Query Performance Optimization
**Goal**: Achieve target latency and throughput

**Steps**:
1. Add query result caching with TTL
2. Implement batch query processing
3. Create query execution profiler
4. Add index statistics for optimization
5. Implement concurrent query handling

**Verify**:
- P95 latency < 10ms for common queries
- Throughput > 100 queries/second
- Cache hit rate > 50% for repeated patterns

### Task 7: API and Testing
**Goal**: Production-ready query interface

**Steps**:
1. Create REST API with FastAPI
2. Add GraphQL endpoint for complex queries
3. Implement comprehensive test suite
4. Add performance benchmarks
5. Create query examples and documentation

**Verify**:
- API handles all query types correctly
- Tests cover edge cases and errors
- Documentation includes 20+ examples

## Example Queries

```python
# Find conflicts between Russia and Ukraine in last 30 days
query1 = {
    "actor1": "RUS",
    "actor2": "UKR",
    "quad_class": 4,
    "time_window": {"days": 30},
    "min_confidence": 0.7
}

# Find entities similar to "NATO" involved in diplomatic events
query2 = {
    "entity_similarity": "NATO",
    "similarity_threshold": 0.8,
    "quad_class": 1,
    "time_window": {"days": 7}
}

# Find causal paths leading to specific conflict
query3 = {
    "target_event": "RUS_UKR_conflict_2024",
    "path_length": 3,
    "time_window": {"days": 90},
    "include_diplomatic": True
}
```

## Success Criteria
- [ ] Query interface handles 10+ query patterns
- [ ] P95 latency < 10ms for simple queries
- [ ] Semantic search improves recall by >30%
- [ ] All results include explanation paths
- [ ] API supports 100 queries/second

## Time Estimate
4-5 hours

## Dependencies
- NetworkX graph from Plan 02-01
- Qdrant embeddings from Plan 02-02
- FastAPI for REST interface
- Query result caching (Redis optional)

## Risk Factors
- Query complexity explosion (mitigation: query timeout)
- Cache invalidation complexity (mitigation: TTL-based eviction)
- Explanation generation overhead (mitigation: lazy evaluation)