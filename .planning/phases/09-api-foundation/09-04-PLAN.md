---
phase: 09-api-foundation
plan: 04
type: execute
wave: 2
depends_on: ["09-01", "09-02"]
files_modified:
  - src/api/app.py
  - src/api/deps.py
  - src/api/errors.py
  - src/api/middleware/__init__.py
  - src/api/middleware/auth.py
  - src/api/middleware/cors.py
  - src/api/routes/__init__.py
  - src/api/routes/v1/__init__.py
  - src/api/routes/v1/router.py
  - src/api/routes/v1/health.py
  - src/api/routes/v1/forecasts.py
  - src/api/routes/v1/countries.py
autonomous: true

must_haves:
  truths:
    - "GET /api/v1/health returns JSON with subsystem statuses (database, redis) without requiring authentication"
    - "GET /api/v1/forecasts/country/SY returns mock ForecastResponse matching the DTO contract"
    - "GET /api/v1/forecasts/{id} returns a single mock forecast by ID"
    - "POST /api/v1/forecasts with valid X-API-Key returns a mock forecast; without key returns 401"
    - "GET /api/v1/countries returns list of CountryRiskSummary DTOs"
    - "Invalid requests return RFC 9457 Problem Details JSON (application/problem+json)"
    - "CORS headers present on responses when Origin header sent"
    - "OpenAPI schema available at /docs with all DTOs documented"
  artifacts:
    - path: "src/api/app.py"
      provides: "FastAPI application factory with middleware and lifespan"
      contains: "def create_app"
    - path: "src/api/routes/v1/forecasts.py"
      provides: "Forecast CRUD endpoints (GET by ID, GET by country, POST)"
      exports: ["router"]
    - path: "src/api/routes/v1/health.py"
      provides: "Health check endpoint"
      contains: "GET"
    - path: "src/api/middleware/auth.py"
      provides: "API key validation against database"
      contains: "verify_api_key"
    - path: "src/api/errors.py"
      provides: "RFC 9457 Problem Details error handlers"
      contains: "ProblemDetail"
  key_links:
    - from: "src/api/routes/v1/forecasts.py"
      to: "src/api/fixtures/factory.py"
      via: "Mock data served until Phase 10 replaces with real queries"
      pattern: "load_fixture|create_mock_forecast"
    - from: "src/api/deps.py"
      to: "src/db/postgres.py"
      via: "Database session dependency injection"
      pattern: "get_async_session"
    - from: "src/api/middleware/auth.py"
      to: "src/db/models.py"
      via: "ApiKey table lookup"
      pattern: "ApiKey"
    - from: "src/api/app.py"
      to: "src/api/routes/v1/router.py"
      via: "Router inclusion with /api/v1 prefix"
      pattern: "include_router"
---

<objective>
Build the FastAPI application with all routes, middleware, and error handling — serving mock fixture data through the DTO contract established in Plan 02.

Purpose: This is the API server that Phases 10 and 12 develop against. Phase 10 replaces mock responses with real database queries. Phase 12 builds the frontend consuming these endpoints. The API must be fully functional with mock data so both downstream phases can start independently.

Output: `uvicorn src.api.app:create_app --factory` starts a server where all endpoints return valid responses. Health endpoint is public. Forecast endpoints require API key auth. OpenAPI docs auto-generated at /docs.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/09-api-foundation/09-CONTEXT.md
@.planning/phases/09-api-foundation/09-RESEARCH.md

# Depends on Plan 01 outputs:
@src/db/postgres.py
@src/db/models.py
@src/settings.py

# Depends on Plan 02 outputs:
@src/api/schemas/forecast.py
@src/api/schemas/health.py
@src/api/schemas/country.py
@src/api/schemas/common.py
@src/api/fixtures/factory.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: FastAPI app factory, dependencies, error handling, and middleware</name>
  <files>
    src/api/app.py
    src/api/deps.py
    src/api/errors.py
    src/api/middleware/__init__.py
    src/api/middleware/auth.py
    src/api/middleware/cors.py
  </files>
  <action>
    1. Create src/api/app.py — FastAPI application factory:
       - `def create_app() -> FastAPI` factory function
       - Lifespan context manager that:
         a. On startup: initializes DB engine (src.db.postgres), calls setup_logging from src.logging_config, seeds a dev API key if ENVIRONMENT=development
         b. On shutdown: disposes DB engine gracefully
       - Register error handlers via src.api.errors.register_error_handlers
       - Register CORS middleware via src.api.middleware.cors
       - Include v1 router at prefix "/api/v1"
       - Set title="Geopol Forecast API", version="2.0.0-dev", description with explainability mention
       - OpenAPI auto-generated at /docs (default FastAPI behavior)

    2. Create src/api/deps.py — FastAPI dependency injection:
       - get_db() -> AsyncGenerator[AsyncSession, None]: wraps get_async_session
       - get_settings() -> Settings: returns cached settings singleton
       - These are the shared dependencies all route handlers use

    3. Create src/api/errors.py — RFC 9457 Problem Details:
       - Import ProblemDetail from schemas.common
       - Exception handlers for:
         a. RequestValidationError -> 422 with type="/errors/validation"
         b. HTTPException -> appropriate status with type="/errors/{status}"
         c. Generic Exception -> 500 with type="/errors/internal" (NO stack trace in response — log it, don't expose it)
       - All error responses use media_type="application/problem+json"
       - register_error_handlers(app: FastAPI) function

    4. Create src/api/middleware/auth.py:
       - APIKeyHeader security scheme for "X-API-Key" header
       - verify_api_key dependency that:
         a. Extracts X-API-Key header
         b. Queries ApiKey table (from src.db.models) for matching, non-revoked key
         c. Returns client_name on success
         d. Raises 401 HTTPException on missing/invalid key
       - This is a FastAPI Depends, not ASGI middleware — applied per-route, not globally (health endpoint must be public)

    5. Create src/api/middleware/cors.py:
       - configure_cors(app: FastAPI) function
       - Reads CORS_ORIGINS from settings
       - If ENVIRONMENT=development: allow all origins (allow_origins=["*"])
       - If ENVIRONMENT=production: allow only configured origins
       - Allow methods: GET, POST, OPTIONS
       - Allow headers: X-API-Key, Content-Type, Accept
       - Expose headers: X-Request-ID (for future tracing)

    6. Create src/api/middleware/__init__.py (empty).
  </action>
  <verify>
    - `uv run python -c "from src.api.app import create_app; app = create_app(); print(f'Routes: {len(app.routes)}')"` creates app without errors
    - `uv run python -c "from src.api.deps import get_db, get_settings; print('Deps OK')"` succeeds
    - `uv run python -c "from src.api.errors import register_error_handlers; print('Errors OK')"` succeeds
    - `uv run python -c "from src.api.middleware.auth import verify_api_key; print('Auth OK')"` succeeds
  </verify>
  <done>FastAPI app factory creates application with lifespan management, RFC 9457 error handling, CORS middleware, and API key authentication dependency. App starts without errors.</done>
</task>

<task type="auto">
  <name>Task 2: API routes — health, forecasts, countries</name>
  <files>
    src/api/routes/__init__.py
    src/api/routes/v1/__init__.py
    src/api/routes/v1/router.py
    src/api/routes/v1/health.py
    src/api/routes/v1/forecasts.py
    src/api/routes/v1/countries.py
  </files>
  <action>
    1. Create directory structure: src/api/routes/, src/api/routes/v1/ with __init__.py files.

    2. Create src/api/routes/v1/health.py:
       - GET /health (no auth required)
       - Returns HealthResponse with subsystem statuses:
         a. "database": attempt async SELECT 1 on PostgreSQL, report healthy/unhealthy
         b. "redis": attempt PING on Redis, report healthy/unhealthy (gracefully handle Redis not available)
         c. "gdelt_store": check if GDELT SQLite file exists, report healthy/unhealthy
       - Overall status: "healthy" if all subsystems healthy, "degraded" if some unhealthy, "unhealthy" if all unhealthy
       - Include timestamp in response

    3. Create src/api/routes/v1/forecasts.py:
       - GET /forecasts/{forecast_id} (auth required):
         - For Phase 9: look up in mock fixtures by forecast_id. Return 404 ProblemDetail if not found.
         - Response model: ForecastResponse

       - GET /forecasts/country/{iso_code} (auth required):
         - For Phase 9: return mock fixtures matching country code. Empty list for unknown countries.
         - Support optional cursor query param for pagination (mock: ignore cursor, return all, has_more=False)
         - Response model: PaginatedResponse[ForecastResponse]

       - GET /forecasts/top (auth required):
         - For Phase 9: return all mock fixtures sorted by probability descending
         - Support optional limit query param (default 10)
         - Response model: PaginatedResponse[ForecastResponse]

       - POST /forecasts (auth required):
         - Accept JSON body: { "question": str, "country_iso": Optional[str], "horizon_days": Optional[int] }
         - For Phase 9: generate a mock forecast using create_mock_forecast with the provided question/country
         - Return 201 with the mock ForecastResponse
         - Phase 10 replaces this with real EnsemblePredictor.predict() calls

       All authenticated endpoints use Depends(verify_api_key). Mark with response_model for OpenAPI schema generation.

    4. Create src/api/routes/v1/countries.py:
       - GET /countries (auth required):
         - For Phase 9: return CountryRiskSummary for each country with mock fixtures (SY, UA, MM)
         - Response model: list[CountryRiskSummary]

       - GET /countries/{iso_code} (auth required):
         - Return single CountryRiskSummary for the given country
         - 404 if country not in mock data

    5. Create src/api/routes/v1/router.py:
       - Create v1_router = APIRouter(prefix="/v1")
       - Include health router (no prefix, no tags needed for health)
       - Include forecasts router with prefix="/forecasts", tags=["forecasts"]
       - Include countries router with prefix="/countries", tags=["countries"]

    6. Seed a development API key on startup:
       - In the lifespan (app.py), when ENVIRONMENT=development:
         a. Check if any API key exists in the database
         b. If not, create one with key="dev-api-key-geopol-2026", client_name="development"
         c. Log the key so the developer knows what to use

    7. Start the server and run integration tests with curl:
       - Ensure docker-compose services (postgres, redis) are running
       - Start uvicorn in background
       - Test each endpoint with curl
  </action>
  <verify>
    Ensure docker-compose postgres and redis are running, then:

    ```bash
    # Start server in background
    uv run uvicorn src.api.app:create_app --factory --host 0.0.0.0 --port 8000 &
    SERVER_PID=$!
    sleep 3

    # Health (no auth)
    curl -s http://localhost:8000/api/v1/health | python -m json.tool

    # Forecasts by country (with auth)
    curl -s -H "X-API-Key: dev-api-key-geopol-2026" http://localhost:8000/api/v1/forecasts/country/SY | python -m json.tool

    # Post forecast (with auth)
    curl -s -X POST http://localhost:8000/api/v1/forecasts \
      -H "X-API-Key: dev-api-key-geopol-2026" \
      -H "Content-Type: application/json" \
      -d '{"question": "Will there be a ceasefire in Syria?"}' | python -m json.tool

    # Post forecast (no auth -> 401)
    curl -s -X POST http://localhost:8000/api/v1/forecasts \
      -H "Content-Type: application/json" \
      -d '{"question": "test"}' | python -m json.tool

    # Countries list
    curl -s -H "X-API-Key: dev-api-key-geopol-2026" http://localhost:8000/api/v1/countries | python -m json.tool

    # OpenAPI schema
    curl -s http://localhost:8000/openapi.json | python -c "import sys,json; d=json.load(sys.stdin); print(f'Paths: {len(d[\"paths\"])}, Schemas: {len(d[\"components\"][\"schemas\"])}')"

    # Cleanup
    kill $SERVER_PID
    ```

    Expected results:
    - Health: 200 with subsystem statuses
    - Country SY: 200 with ForecastResponse items
    - POST with key: 201 with ForecastResponse
    - POST without key: 401 with ProblemDetail
    - Countries: 200 with CountryRiskSummary list
    - OpenAPI: paths >= 6, schemas >= 8
  </verify>
  <done>All API endpoints return valid responses. Health is public. Forecast/country endpoints require API key. POST without key returns 401. OpenAPI schema auto-generated with all DTOs. RFC 9457 error format on all errors.</done>
</task>

</tasks>

<verification>
1. `GET /api/v1/health` returns 200 with subsystem statuses
2. `GET /api/v1/forecasts/country/SY` returns mock ForecastResponse data
3. `POST /api/v1/forecasts` with API key returns 201; without returns 401
4. `GET /api/v1/countries` returns CountryRiskSummary list
5. `/openapi.json` has all paths and schemas
6. Error responses use application/problem+json format
</verification>

<success_criteria>
- FastAPI server starts with `uvicorn src.api.app:create_app --factory`
- All endpoints return structurally valid DTO responses
- API key auth enforced on all endpoints except health
- CORS configured (permissive in dev, strict in prod)
- OpenAPI schema auto-generated from Pydantic DTOs
- RFC 9457 Problem Details on all error responses
- Dev API key seeded on startup in development mode
</success_criteria>

<output>
After completion, create `.planning/phases/09-api-foundation/09-04-SUMMARY.md`
</output>
