---
phase: 09-api-foundation
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/knowledge_graph/vector_store.py
  - src/knowledge_graph/evaluation.py
  - src/knowledge_graph/embedding_trainer.py
  - src/forecasting/ensemble_predictor.py
  - src/forecasting/forecast_engine.py
  - src/forecasting/scenario_generator.py
  - src/forecasting/gemini_client.py
  - src/bootstrap/checkpoint.py
  - src/training/data_processor.py
autonomous: true

must_haves:
  truths:
    - "No print() statements remain in production source files (src/ excluding test files)"
    - "All production modules use Python logging with module-qualified logger names"
    - "Existing logic and behavior is unchanged — only print() calls are replaced"
  artifacts:
    - path: "src/knowledge_graph/vector_store.py"
      provides: "vector_store with logging instead of print"
      contains: "logger = logging.getLogger(__name__)"
    - path: "src/forecasting/ensemble_predictor.py"
      provides: "ensemble_predictor with logging instead of print"
      contains: "logger = logging.getLogger(__name__)"
    - path: "src/bootstrap/checkpoint.py"
      provides: "checkpoint with logging instead of print"
      contains: "logger = logging.getLogger(__name__)"
  key_links:
    - from: "all modified files"
      to: "src/logging_config.py"
      via: "logging module configured by setup_logging()"
      pattern: "logging\\.getLogger\\(__name__\\)"
---

<objective>
Convert all print() statements in production source files to structured logging calls.

Purpose: Structured logging is mandatory for production (Phase 10 ingest daemon and daily pipeline need log-based monitoring, Phase 13 health observability reads log streams). This is a mechanical sweep across 9 files with ~60 print() statements. No logic changes — only print() -> logger.{level}() replacements. This plan is independent of Plan 03 (jraph/protocol/logging_config) at execution time — it uses the standard `logging` module, not `src/logging_config.py`. The logging_config merely configures formatters; the getLogger(__name__) calls work regardless.

Output: Zero print() statements in any production source file under src/.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/09-api-foundation/09-RESEARCH.md

# Print statement audit from RESEARCH.md — reference for logging conversion
# Files to convert (9 files, ~60 print statements):
@src/knowledge_graph/vector_store.py
@src/knowledge_graph/evaluation.py
@src/knowledge_graph/embedding_trainer.py
@src/forecasting/ensemble_predictor.py
@src/forecasting/forecast_engine.py
@src/forecasting/scenario_generator.py
@src/forecasting/gemini_client.py
@src/bootstrap/checkpoint.py
@src/training/data_processor.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert print() to logging in knowledge_graph and training modules</name>
  <files>
    src/knowledge_graph/vector_store.py
    src/knowledge_graph/evaluation.py
    src/knowledge_graph/embedding_trainer.py
    src/training/data_processor.py
  </files>
  <action>
    Convert print() -> logging in these 4 files (~45 print statements total):

    - src/knowledge_graph/vector_store.py (~18 prints -> logger.info/debug/warning)
    - src/knowledge_graph/evaluation.py (~13 prints -> logger.info/debug)
    - src/knowledge_graph/embedding_trainer.py (~12 prints -> logger.info/debug)
    - src/training/data_processor.py (2 prints -> logger.info)

    For each file:
    a. Add `import logging` if not present
    b. Add `logger = logging.getLogger(__name__)` after imports
    c. Replace each print() with appropriate log level:
       - Status/progress messages -> logger.info()
       - Debug details (shapes, counts, intermediate values) -> logger.debug()
       - Error messages/fallbacks -> logger.error() or logger.warning()
       - f-string formatting stays the same (logging supports f-strings)

    DO NOT:
    - Change any logic, only the print() calls
    - Convert test files (src/knowledge_graph/test_*.py) — those are fine with print()
    - Remove any existing logging calls that are already correct
  </action>
  <verify>
    - `grep -rn "^[^#]*print(" src/knowledge_graph/ src/training/data_processor.py --include="*.py" | grep -v test_ | grep -v __pycache__` returns zero results
    - `uv run python -c "from src.knowledge_graph.vector_store import VectorStore; print('vector_store OK')"` succeeds
    - `uv run python -c "from src.knowledge_graph.evaluation import Evaluator; print('evaluation OK')"` succeeds (or whatever the main class is)
    - `uv run python -c "from src.knowledge_graph.embedding_trainer import EmbeddingTrainer; print('embedding_trainer OK')"` succeeds (or whatever the main export is)
  </verify>
  <done>Zero print() in knowledge_graph production files and training/data_processor.py. All use logger = logging.getLogger(__name__) with appropriate log levels.</done>
</task>

<task type="auto">
  <name>Task 2: Convert print() to logging in forecasting and bootstrap modules</name>
  <files>
    src/forecasting/ensemble_predictor.py
    src/forecasting/forecast_engine.py
    src/forecasting/scenario_generator.py
    src/forecasting/gemini_client.py
    src/bootstrap/checkpoint.py
  </files>
  <action>
    Convert print() -> logging in these 5 files (~16 print statements total):

    - src/forecasting/ensemble_predictor.py (4 prints -> logger.info/warning)
    - src/forecasting/forecast_engine.py (3 prints -> logger.info/warning)
    - src/forecasting/scenario_generator.py (2 prints -> logger.warning)
    - src/forecasting/gemini_client.py (1 print -> logger.error)
    - src/bootstrap/checkpoint.py (6 prints -> logger.info)

    Same rules as Task 1:
    a. Add `import logging` if not present
    b. Add `logger = logging.getLogger(__name__)` after imports
    c. Replace each print() with appropriate log level
    d. DO NOT change any logic

    After both tasks, do a final sweep:
    `grep -rn "^[^#]*print(" src/ --include="*.py" | grep -v test_ | grep -v __pycache__`
    This must return zero results for production files.
  </action>
  <verify>
    - `grep -rn "^[^#]*print(" src/forecasting/ src/bootstrap/ --include="*.py" | grep -v test_ | grep -v __pycache__` returns zero results
    - Full sweep: `grep -rn "^[^#]*print(" src/ --include="*.py" | grep -v test_ | grep -v __pycache__` returns zero production file results
    - `uv run python -c "from src.forecasting.ensemble_predictor import EnsemblePredictor; print('OK')"` succeeds
    - `uv run python -c "from src.bootstrap.checkpoint import CheckpointManager; print('OK')"` succeeds (or whatever the main export is)
  </verify>
  <done>Zero print() statements in any production source file under src/. All 9 files converted to structured logging with module-qualified logger names. No logic changes.</done>
</task>

</tasks>

<verification>
1. `grep -rn "^[^#]*print(" src/ --include="*.py" | grep -v test_ | grep -v __pycache__` returns zero results for production files
2. All modified modules import successfully without errors
3. No logic changes — only print() -> logger calls
</verification>

<success_criteria>
- Zero print() statements in production src/ files (excluding test files)
- All 9 files have `logger = logging.getLogger(__name__)`
- Log levels are appropriate (info for status, debug for details, warning/error for problems)
- No behavioral changes — all existing logic preserved
</success_criteria>

<output>
After completion, create `.planning/phases/09-api-foundation/09-04-SUMMARY.md`
</output>
