---
phase: 09-api-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/api/__init__.py
  - src/api/schemas/__init__.py
  - src/api/schemas/forecast.py
  - src/api/schemas/health.py
  - src/api/schemas/country.py
  - src/api/schemas/common.py
  - src/api/fixtures/__init__.py
  - src/api/fixtures/factory.py
  - src/api/fixtures/scenarios/syria.json
  - src/api/fixtures/scenarios/ukraine.json
  - src/api/fixtures/scenarios/myanmar.json
autonomous: true

must_haves:
  truths:
    - "ForecastResponse DTO validates with all nested DTOs (ScenarioDTO, EvidenceDTO, CalibrationDTO, EnsembleInfoDTO)"
    - "ScenarioDTO supports recursive child_scenarios without forward reference errors"
    - "Mock fixtures for Syria, Ukraine, Myanmar are structurally valid ForecastResponse objects with realistic geopolitical content"
    - "Factory function generates N random forecasts with valid probability distributions"
    - "CountryRiskSummary validates with trend enum and risk_score bounds"
    - "PaginatedResponse generic works with ForecastResponse items and cursor tokens"
    - "HealthResponse schema supports 8 named subsystems with typed detail fields"
  artifacts:
    - path: "src/api/schemas/forecast.py"
      provides: "ForecastResponse, ScenarioDTO, EvidenceDTO, CalibrationDTO, EnsembleInfoDTO DTOs"
      contains: "class ForecastResponse"
    - path: "src/api/schemas/country.py"
      provides: "CountryRiskSummary DTO"
      contains: "class CountryRiskSummary"
    - path: "src/api/schemas/health.py"
      provides: "HealthResponse with 8 subsystem schema"
      contains: "class SubsystemStatus"
    - path: "src/api/schemas/common.py"
      provides: "ProblemDetail, PaginatedResponse, cursor encode/decode"
      contains: "class PaginatedResponse"
    - path: "src/api/fixtures/factory.py"
      provides: "Mock forecast factory and fixture loader"
      contains: "def create_mock_forecast"
    - path: "src/api/fixtures/scenarios/syria.json"
      provides: "Syria mock forecast fixture"
      min_lines: 30
  key_links:
    - from: "src/api/schemas/forecast.py"
      to: "WORLDMONITOR_INTEGRATION.md"
      via: "DTO contract spec (lines 328-382)"
      pattern: "class ForecastResponse"
    - from: "src/api/fixtures/factory.py"
      to: "src/api/schemas/forecast.py"
      via: "factory validates output against DTOs"
      pattern: "ForecastResponse\\.model_validate"
---

<objective>
Define the Pydantic V2 DTO contract and mock fixtures that establish the API surface for Phases 10 and 12 to develop against independently.

Purpose: The DTOs are the critical output of Phase 9 — they are the contract that the frontend (Phase 12) and backend pipeline (Phase 10) both code to. Mock fixtures let the frontend render realistic data before real forecasts exist. This plan is independent of the database layer (DTOs are API schemas, not ORM models).

Output: All 6 Pydantic DTOs importable from `src.api.schemas`. Three country-specific JSON fixtures (SY, UA, MM) loadable as validated ForecastResponse objects. A factory function for generating arbitrary mock forecasts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/09-api-foundation/09-CONTEXT.md
@.planning/phases/09-api-foundation/09-RESEARCH.md

# THE locked DTO contract — implement exactly this:
@WORLDMONITOR_INTEGRATION.md (lines 328-382)

# Existing Pydantic models in the codebase (for consistency):
@src/forecasting/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pydantic V2 DTO schemas</name>
  <files>
    src/api/__init__.py
    src/api/schemas/__init__.py
    src/api/schemas/forecast.py
    src/api/schemas/health.py
    src/api/schemas/country.py
    src/api/schemas/common.py
  </files>
  <action>
    1. Create directory structure: src/api/, src/api/schemas/ with __init__.py files.

    2. Create src/api/schemas/forecast.py implementing the 5 forecast-related DTOs from WORLDMONITOR_INTEGRATION.md lines 328-382:

       - EvidenceDTO: source (str), description (str), confidence (float, ge=0, le=1), timestamp (Optional[datetime]), gdelt_event_id (Optional[str])

       - EnsembleInfoDTO: llm_probability (float), tkg_probability (Optional[float]), weights (dict[str, float]), temperature_applied (float)

       - CalibrationDTO: category (str), temperature (float), historical_accuracy (float, ge=0, le=1), brier_score (Optional[float]), sample_size (int, ge=0)

       - ScenarioDTO: scenario_id (str), description (str), probability (float, ge=0, le=1), answers_affirmative (bool), entities (list[str]), timeline (list[str]), evidence_sources (list[EvidenceDTO]), child_scenarios (list["ScenarioDTO"])
         CRITICAL: After class definition, call ScenarioDTO.model_rebuild() to resolve the self-referential forward reference. Without this, Pydantic V2 will raise PydanticUserError during schema generation.

       - ForecastResponse: forecast_id (str), question (str), prediction (str), probability (float, ge=0, le=1), confidence (float, ge=0, le=1), horizon_days (int, gt=0), scenarios (list[ScenarioDTO]), reasoning_summary (str), evidence_count (int, ge=0), ensemble_info (EnsembleInfoDTO), calibration (CalibrationDTO), created_at (datetime), expires_at (datetime)

       All models must use `model_config = ConfigDict(from_attributes=True)` to enable ORM mode conversion.

    3. Create src/api/schemas/country.py:
       - CountryRiskSummary: iso_code (str, min_length=2, max_length=3), risk_score (float, ge=0, le=1), forecast_count (int, ge=0), top_question (str), top_probability (float, ge=0, le=1), trend (Literal["rising", "stable", "falling"]), last_updated (datetime)

    4. Create src/api/schemas/health.py:
       - SubsystemStatus: name (str), healthy (bool), detail (Optional[str]), checked_at (datetime)
         The name field must be one of the 8 canonical subsystem names: "database", "redis", "gdelt_store", "graph_partitions", "tkg_model", "last_ingest", "last_prediction", "api_budget".
       - HealthResponse: status (Literal["healthy", "degraded", "unhealthy"]), subsystems (list[SubsystemStatus]), timestamp (datetime), version (str)
         This schema is intentionally broad — it accommodates all 8 subsystem checks that SC-1 requires. Individual subsystem checkers are implemented in Plan 05 (routes).

    5. Create src/api/schemas/common.py:
       - ProblemDetail: type (str, default="about:blank"), title (str), status (int), detail (Optional[str]), instance (Optional[str])
       - PaginatedResponse (Generic[T]): items (list[T]), next_cursor (Optional[str]), has_more (bool)
       - encode_cursor(forecast_id: str, created_at: str) -> str: base64url encode JSON
       - decode_cursor(cursor: str) -> dict: base64url decode JSON

    6. Create src/api/schemas/__init__.py re-exporting all public DTOs for convenient import.
  </action>
  <verify>
    - `uv run python -c "
from src.api.schemas.forecast import ForecastResponse, ScenarioDTO, EvidenceDTO, CalibrationDTO, EnsembleInfoDTO
from src.api.schemas.country import CountryRiskSummary
from src.api.schemas.health import HealthResponse, SubsystemStatus
from src.api.schemas.common import ProblemDetail, PaginatedResponse
print('All DTOs importable')

# Test ScenarioDTO self-reference
import json
s = ScenarioDTO(
    scenario_id='s1', description='test', probability=0.7,
    answers_affirmative=True, entities=['Syria'], timeline=['T+1 week'],
    evidence_sources=[], child_scenarios=[
        ScenarioDTO(scenario_id='s1.1', description='child', probability=0.3,
                    answers_affirmative=False, entities=[], timeline=[],
                    evidence_sources=[], child_scenarios=[])
    ]
)
print('Recursive ScenarioDTO:', s.model_dump_json()[:100])

# Test ForecastResponse full schema
schema = ForecastResponse.model_json_schema()
print('Schema fields:', len(schema.get('properties', {})))

# Test HealthResponse with 8 subsystems
from datetime import datetime, timezone
subs = [SubsystemStatus(name=n, healthy=True, detail='ok', checked_at=datetime.now(timezone.utc))
        for n in ['database','redis','gdelt_store','graph_partitions','tkg_model','last_ingest','last_prediction','api_budget']]
hr = HealthResponse(status='healthy', subsystems=subs, timestamp=datetime.now(timezone.utc), version='2.0.0-dev')
print(f'HealthResponse with {len(hr.subsystems)} subsystems')
"` succeeds without errors
    - `uv run python -c "from src.api.schemas.common import encode_cursor, decode_cursor; c = encode_cursor('abc', '2026-01-01'); print(decode_cursor(c))"` round-trips correctly
  </verify>
  <done>All 6 DTOs plus ProblemDetail, PaginatedResponse, and HealthResponse are importable and validate correctly. ScenarioDTO handles recursive nesting. ForecastResponse generates valid OpenAPI schema. HealthResponse supports all 8 subsystem status entries.</done>
</task>

<task type="auto">
  <name>Task 2: Mock fixtures — Syria, Ukraine, Myanmar scenarios + factory</name>
  <files>
    src/api/fixtures/__init__.py
    src/api/fixtures/factory.py
    src/api/fixtures/scenarios/syria.json
    src/api/fixtures/scenarios/ukraine.json
    src/api/fixtures/scenarios/myanmar.json
  </files>
  <action>
    1. Create src/api/fixtures/scenarios/ directory.

    2. Create syria.json — a hand-crafted ForecastResponse JSON representing a realistic Syria forecast:
       - Question: something about Syrian conflict dynamics (e.g., "Will there be a significant escalation in the Syrian civil conflict within the next 30 days?")
       - 2-3 scenarios with branching child_scenarios
       - Evidence sources referencing GDELT events and TKG patterns
       - Calibration data for "conflict" category
       - Ensemble info showing LLM/TKG split
       - Realistic entities: Syria, Turkey, SDF, Russia, Iran
       - Timeline events spanning 1-4 weeks
       - Probability distributions that sum sensibly across scenarios
       - Realistic entities: Syria, Turkey, SDF, Russia, Iran

    3. Create ukraine.json — realistic Ukraine conflict forecast:
       - Question about Ukraine-Russia conflict trajectory
       - Different scenario structure than Syria (diplomatic vs military branches)
       - Entities: Ukraine, Russia, NATO, EU
       - Calibration for "conflict" category

    4. Create myanmar.json — realistic Myanmar political instability forecast:
       - Question about Myanmar military junta stability
       - Entities: Myanmar, NUG, ASEAN
       - Calibration for "diplomatic" category (different from conflict)
       - Fewer scenarios (testing smaller response)

    5. Create src/api/fixtures/factory.py:
       - load_fixture(country_code: str) -> ForecastResponse: loads and validates JSON fixture. Raises FileNotFoundError for unknown countries.
       - load_all_fixtures() -> dict[str, ForecastResponse]: loads all 3.
       - create_mock_forecast(country_iso: str = "XX", question: str = "...", **overrides) -> ForecastResponse: generates a random but valid forecast with plausible data. Uses random.Random with optional seed for reproducibility.
       - create_mock_country_risk(iso_code: str) -> CountryRiskSummary: generates a risk summary from fixture data.
       - get_empty_country_response(iso_code: str) -> list: returns empty list (for testing empty state — country with no forecasts, e.g., "FI").

    6. Create src/api/fixtures/__init__.py exporting load_fixture, load_all_fixtures, create_mock_forecast.

    ALL fixture data must validate against the Pydantic DTOs. The factory.py MUST call ForecastResponse.model_validate() on its output to guarantee structural validity. Garbage in, garbage out — if the mock data doesn't match the schema, the frontend will build against lies.
  </action>
  <verify>
    - `uv run python -c "
from src.api.fixtures.factory import load_fixture, load_all_fixtures, create_mock_forecast
from src.api.schemas.forecast import ForecastResponse

# Load all fixtures
fixtures = load_all_fixtures()
print(f'Loaded {len(fixtures)} fixtures: {list(fixtures.keys())}')

# Validate each fixture
for code, f in fixtures.items():
    assert isinstance(f, ForecastResponse), f'{code} is not ForecastResponse'
    assert len(f.scenarios) >= 1, f'{code} has no scenarios'
    assert f.probability >= 0 and f.probability <= 1
    print(f'{code}: {f.question[:60]}... ({len(f.scenarios)} scenarios)')

# Test factory
mock = create_mock_forecast(country_iso='DE', question='Will Germany increase defense spending?')
assert isinstance(mock, ForecastResponse)
print(f'Factory: {mock.forecast_id}, p={mock.probability:.2f}')

# Test empty country
from src.api.fixtures.factory import get_empty_country_response
empty = get_empty_country_response('FI')
assert empty == []
print('Empty country response OK')
print('ALL FIXTURE TESTS PASSED')
"` succeeds
  </verify>
  <done>Three country fixtures (SY, UA, MM) load and validate as ForecastResponse objects with realistic geopolitical content. Factory generates arbitrary valid mock forecasts. Empty state handled for unknown countries.</done>
</task>

</tasks>

<verification>
1. All 6 DTOs import and validate — including recursive ScenarioDTO
2. ForecastResponse.model_json_schema() generates valid OpenAPI schema
3. All 3 JSON fixtures load and pass ForecastResponse validation
4. Factory function produces structurally valid random forecasts
5. PaginatedResponse generic works with ForecastResponse items
6. HealthResponse schema accepts all 8 subsystem status entries
</verification>

<success_criteria>
- Pydantic DTOs match the contract spec in WORLDMONITOR_INTEGRATION.md exactly
- Mock fixtures contain geopolitically plausible data for Syria, Ukraine, Myanmar
- Factory function creates valid ForecastResponse objects on demand
- All schemas generate valid OpenAPI JSON schema
- No forward reference errors in recursive ScenarioDTO
- HealthResponse schema supports 8 named subsystems with checked_at timestamps
</success_criteria>

<output>
After completion, create `.planning/phases/09-api-foundation/09-02-SUMMARY.md`
</output>
