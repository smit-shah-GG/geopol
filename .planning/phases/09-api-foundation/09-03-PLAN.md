---
phase: 09-api-foundation
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/training/models/regcn_jraph.py
  - src/training/train_jraph.py
  - scripts/train_tkg_jraph.py
  - src/protocols/__init__.py
  - src/protocols/tkg.py
  - src/logging_config.py
  - src/knowledge_graph/vector_store.py
  - src/knowledge_graph/evaluation.py
  - src/knowledge_graph/embedding_trainer.py
  - src/forecasting/ensemble_predictor.py
  - src/forecasting/forecast_engine.py
  - src/forecasting/scenario_generator.py
  - src/forecasting/gemini_client.py
  - src/bootstrap/checkpoint.py
  - src/training/data_processor.py
autonomous: true

must_haves:
  truths:
    - "Importing src.training.models.regcn_jraph succeeds without jraph installed"
    - "TKGModelProtocol is defined with runtime_checkable and REGCNJraph satisfies isinstance check"
    - "A stub TiRGN class satisfies TKGModelProtocol isinstance check"
    - "No print() statements remain in production source files (src/ excluding test files)"
    - "All production modules use Python logging with module-qualified logger names"
  artifacts:
    - path: "src/protocols/tkg.py"
      provides: "TKGModelProtocol with evolve_embeddings, compute_scores, compute_loss"
      contains: "@runtime_checkable"
    - path: "src/training/models/regcn_jraph.py"
      provides: "RE-GCN implementation using local GraphsTuple instead of jraph"
      contains: "class GraphsTuple(NamedTuple)"
    - path: "src/logging_config.py"
      provides: "Structured logging configuration (human-readable + JSON modes)"
      contains: "def setup_logging"
  key_links:
    - from: "src/training/models/regcn_jraph.py"
      to: "jax.ops.segment_sum"
      via: "replaces jraph.segment_sum"
      pattern: "jax\\.ops\\.segment_sum|jnp\\.zeros.*\\.at.*\\.add"
    - from: "src/protocols/tkg.py"
      to: "src/training/models/regcn_jraph.py"
      via: "REGCNJraph satisfies TKGModelProtocol"
      pattern: "isinstance.*TKGModelProtocol"
---

<objective>
Eliminate the archived jraph dependency, define the TKGModelProtocol for swappable model backends, and convert all print() statements to structured logging.

Purpose: jraph was archived by Google DeepMind in May 2025 and is a ticking time bomb in the dependency tree. The TKGModelProtocol enables Phase 11 to swap RE-GCN for TiRGN without touching downstream code. Structured logging is mandatory for production (Phase 10 ingest daemon and daily pipeline need log-based monitoring). These three concerns share zero files and are all independent of the API/DB work in Plans 01, 02, and 04.

Output: `import jraph` no longer appears anywhere in the codebase. `TKGModelProtocol` is defined and verified. All production code uses `logging.getLogger(__name__)`.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/09-api-foundation/09-RESEARCH.md

# jraph-free template (already exists in codebase):
@src/training/models/regcn_jax.py

# Files to modify (jraph elimination):
@src/training/models/regcn_jraph.py
@src/training/train_jraph.py
@scripts/train_tkg_jraph.py

# Print statement audit from RESEARCH.md — reference for logging conversion
</context>

<tasks>

<task type="auto">
  <name>Task 1: Eliminate jraph — replace with local JAX equivalents</name>
  <files>
    src/training/models/regcn_jraph.py
    src/training/train_jraph.py
    scripts/train_tkg_jraph.py
  </files>
  <action>
    The replacement is mechanical. regcn_jax.py already demonstrates the jraph-free pattern.

    In src/training/models/regcn_jraph.py:
    1. Remove `import jraph` (line 18)
    2. Add a local GraphsTuple NamedTuple replacing jraph.GraphsTuple:
       ```python
       class GraphsTuple(NamedTuple):
           """Local replacement for jraph.GraphsTuple (archived library)."""
           nodes: Optional[Array]
           edges: Optional[Array]
           senders: Array
           receivers: Array
           n_node: Array
           n_edge: Array
           globals: Optional[Array] = None
       ```
    3. Replace `jraph.GraphsTuple(...)` call in create_graph() (line 61) with local `GraphsTuple(...)` — the constructor signature is identical.
    4. Replace `jraph.segment_sum(masked_messages, receivers, num_segments=num_nodes)` (line 159) with `jax.ops.segment_sum(masked_messages, receivers, num_segments=num_nodes)` — identical API.
    5. Replace `jraph.segment_sum(ones, receivers, num_segments=num_nodes)` (line 170) with `jax.ops.segment_sum(ones, receivers, num_segments=num_nodes)`.
    6. Update module docstring to reflect jraph removal.

    In src/training/train_jraph.py:
    - Verify imports from regcn_jraph still work (they import REGCNJraph, TemporalGraph, create_graph, create_model — none of these change names). No code changes should be needed unless there are direct jraph imports.

    In scripts/train_tkg_jraph.py:
    - Same check — this imports from train_jraph. Verify import chain works without jraph.

    IMPORTANT: After all changes, verify the entire import chain works:
    `python -c "from src.training.models.regcn_jraph import REGCNJraph, create_graph; from src.training.train_jraph import TrainingConfig; print('jraph eliminated')"` must succeed without jraph installed (it was already removed from pyproject.toml in Plan 01, but if Plan 01 hasn't run yet, this verifies the code is clean regardless).
  </action>
  <verify>
    - `grep -r "import jraph" src/ scripts/` returns zero results
    - `uv run python -c "from src.training.models.regcn_jraph import REGCNJraph, TemporalGraph, create_graph, create_model; print('Import OK')"` succeeds
    - `uv run python -c "from src.training.train_jraph import TrainingConfig; print('Train import OK')"` succeeds
    - `uv run python -c "
from src.training.models.regcn_jraph import REGCNJraph, create_graph
from flax import nnx
import jax.numpy as jnp

# Smoke test: create model and process a tiny graph
model = create_model(num_entities=10, num_relations=5)
graph = create_graph(
    senders=jnp.array([0, 1, 2]),
    receivers=jnp.array([1, 2, 0]),
    relation_types=jnp.array([0, 1, 2]),
    num_nodes=10,
)
emb = model.evolve_embeddings([graph], training=False)
print(f'Embeddings shape: {emb.shape}')
assert emb.shape == (10, 200), f'Expected (10, 200), got {emb.shape}'
print('Smoke test PASSED')
"` succeeds
  </verify>
  <done>Zero jraph imports remain. regcn_jraph.py uses local GraphsTuple NamedTuple and jax.ops.segment_sum. Model creation and forward pass work identically to before.</done>
</task>

<task type="auto">
  <name>Task 2: TKGModelProtocol + stub TiRGN + structured logging</name>
  <files>
    src/protocols/__init__.py
    src/protocols/tkg.py
    src/logging_config.py
    src/knowledge_graph/vector_store.py
    src/knowledge_graph/evaluation.py
    src/knowledge_graph/embedding_trainer.py
    src/forecasting/ensemble_predictor.py
    src/forecasting/forecast_engine.py
    src/forecasting/scenario_generator.py
    src/forecasting/gemini_client.py
    src/bootstrap/checkpoint.py
    src/training/data_processor.py
  </files>
  <action>
    PART A — TKGModelProtocol:

    1. Create src/protocols/__init__.py (empty).
    2. Create src/protocols/tkg.py:
       - Import Protocol, runtime_checkable from typing
       - Define TKGModelProtocol with @runtime_checkable:
         - Attributes: num_entities (int), num_relations (int), embedding_dim (int)
         - Methods:
           - evolve_embeddings(self, snapshots: list, training: bool = False) -> Array
           - compute_scores(self, entity_emb: Array, triples: Array) -> Array
           - compute_loss(self, snapshots: list, pos_triples: Array, neg_triples: Array, margin: float = 1.0, **kwargs) -> Array
       - Define StubTiRGN class that minimally satisfies the protocol:
         - __init__(self, num_entities, num_relations, embedding_dim=200)
         - evolve_embeddings returns jnp.zeros((num_entities, embedding_dim))
         - compute_scores returns jnp.zeros((triples.shape[0],))
         - compute_loss returns jnp.array(0.0)
         - This is a STUB — Phase 11 implements the real TiRGN
    3. Verify REGCNJraph (from regcn_jraph.py) satisfies the protocol via isinstance check.
       Note: REGCNJraph uses `graphs: List[TemporalGraph]` for its first parameter while the protocol says `snapshots: list`. Python Protocols check structural compatibility — the parameter name doesn't matter, only the signature types. If isinstance fails, adjust the protocol's method signatures to match REGCNJraph's actual signatures more precisely (the protocol adapts to the implementation, not vice versa, since REGCNJraph is battle-tested code).

    PART B — Structured Logging:

    4. Create src/logging_config.py:
       - setup_logging(level: str = "INFO", json_format: bool = False) -> None
       - Human-readable format for dev: "%(asctime)s [%(levelname)s] %(name)s: %(message)s"
       - JSON format for production: {"timestamp", "level", "module", "message", "logger"}
       - Clears existing handlers, adds single StreamHandler to stderr

    5. Convert print() -> logging in ALL production source files (NOT test files — those are lower priority and can stay for now):
       - src/knowledge_graph/vector_store.py (~18 prints -> logger.info/debug/warning)
       - src/knowledge_graph/evaluation.py (~13 prints -> logger.info/debug)
       - src/knowledge_graph/embedding_trainer.py (~12 prints -> logger.info/debug)
       - src/forecasting/ensemble_predictor.py (4 prints -> logger.info/warning)
       - src/forecasting/forecast_engine.py (3 prints -> logger.info/warning)
       - src/forecasting/scenario_generator.py (2 prints -> logger.warning)
       - src/forecasting/gemini_client.py (1 print -> logger.error)
       - src/bootstrap/checkpoint.py (6 prints -> logger.info)
       - src/training/data_processor.py (2 prints -> logger.info)

       For each file:
       a. Add `import logging` if not present
       b. Add `logger = logging.getLogger(__name__)` after imports
       c. Replace each print() with appropriate log level:
          - Status/progress messages -> logger.info()
          - Debug details -> logger.debug()
          - Error messages/fallbacks -> logger.error() or logger.warning()
          - f-string formatting stays the same (logging supports f-strings)

       DO NOT:
       - Change any logic, only the print() calls
       - Convert test files (src/knowledge_graph/test_*.py) — those are fine with print()
       - Remove any existing logging calls that are already correct
  </action>
  <verify>
    - Protocol verification:
      `uv run python -c "
from src.protocols.tkg import TKGModelProtocol, StubTiRGN
from src.training.models.regcn_jraph import REGCNJraph, create_model

# Verify stub satisfies protocol
stub = StubTiRGN(num_entities=100, num_relations=20)
assert isinstance(stub, TKGModelProtocol), 'StubTiRGN does not satisfy TKGModelProtocol'
print('StubTiRGN: protocol check PASSED')

# Verify REGCNJraph satisfies protocol
model = create_model(num_entities=100, num_relations=20)
assert isinstance(model, TKGModelProtocol), 'REGCNJraph does not satisfy TKGModelProtocol'
print('REGCNJraph: protocol check PASSED')
"` succeeds

    - Logging verification:
      `grep -rn "^[^#]*print(" src/ --include="*.py" | grep -v test_ | grep -v __pycache__` returns zero results for production files

    - Logging config verification:
      `uv run python -c "
from src.logging_config import setup_logging
setup_logging(level='DEBUG')
import logging
logger = logging.getLogger('test')
logger.info('Structured logging works')
print('Logging config OK')
"` produces formatted log output
  </verify>
  <done>TKGModelProtocol defined with @runtime_checkable. Both REGCNJraph and StubTiRGN satisfy it via isinstance. Zero print() statements in production source files — all converted to logging with module-qualified logger names. Structured logging configuration supports human-readable (dev) and JSON (production) formats.</done>
</task>

</tasks>

<verification>
1. `grep -r "import jraph" src/ scripts/` returns nothing
2. `isinstance(create_model(10, 5), TKGModelProtocol)` is True
3. `isinstance(StubTiRGN(10, 5), TKGModelProtocol)` is True
4. Zero print() in production src/ files (excluding test files)
5. `setup_logging()` configures root logger with structured format
</verification>

<success_criteria>
- jraph fully eliminated — zero imports, local GraphsTuple + jax.ops.segment_sum used instead
- RE-GCN model creates and runs forward pass identically to before
- TKGModelProtocol is @runtime_checkable and both REGCNJraph and StubTiRGN satisfy it
- All production print() statements converted to logging calls
- Structured logging config exists with dev/production format modes
</success_criteria>

<output>
After completion, create `.planning/phases/09-api-foundation/09-03-SUMMARY.md`
</output>
