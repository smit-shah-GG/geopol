---
phase: 08-graph-partitioning
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/knowledge_graph/boundary_resolver.py
  - src/knowledge_graph/cross_partition_query.py
  - src/knowledge_graph/partitioned_graph.py
  - tests/test_boundary_resolver.py
  - tests/test_cross_partition_query.py
  - tests/test_partitioned_graph.py
autonomous: true

must_haves:
  truths:
    - "Boundary entities are identified and replicated across partitions"
    - "Cross-partition queries return same results as single-graph queries"
    - "Query router executes scatter-gather pattern across partitions"
    - "PartitionedTemporalGraph provides unified interface over partitions"
    - "Performance degradation is less than 2x for partitioned vs unpartitioned"
  artifacts:
    - path: "src/knowledge_graph/boundary_resolver.py"
      provides: "BoundaryResolver for cross-partition entity replication"
      exports: ["BoundaryResolver", "BoundaryEntity"]
      contains: "identify_boundary_entities"
    - path: "src/knowledge_graph/cross_partition_query.py"
      provides: "QueryRouter for scatter-gather queries"
      exports: ["QueryRouter"]
      contains: "scatter.*gather|execute.*parallel"
    - path: "src/knowledge_graph/partitioned_graph.py"
      provides: "PartitionedTemporalGraph unified interface"
      exports: ["PartitionedTemporalGraph"]
      contains: "k_hop_neighborhood"
    - path: "tests/test_cross_partition_query.py"
      provides: "Query correctness tests comparing partitioned vs full graph"
      min_lines: 100
  key_links:
    - from: "src/knowledge_graph/partitioned_graph.py"
      to: "src/knowledge_graph/partition_manager.py"
      via: "partition loading"
      pattern: "PartitionManager"
    - from: "src/knowledge_graph/cross_partition_query.py"
      to: "src/knowledge_graph/partition_index.py"
      via: "entity routing"
      pattern: "get_entity_partitions"
    - from: "src/knowledge_graph/partitioned_graph.py"
      to: "src/knowledge_graph/graph_traversal.py"
      via: "k_hop_neighborhood delegation"
      pattern: "GraphTraversal|k_hop_neighborhood"
---

<objective>
Implement cross-partition query infrastructure: boundary entity resolution, scatter-gather query router, and unified PartitionedTemporalGraph interface.

Purpose: This plan enables query correctness across partition boundaries. The boundary resolver identifies entities appearing in multiple partitions and marks their home/replica status. The query router implements scatter-gather to execute queries across relevant partitions and merge results. The PartitionedTemporalGraph provides a drop-in interface matching the existing GraphTraversal API.

Output: Three new modules completing the partitioning system, with correctness tests proving query equivalence between partitioned and unpartitioned graphs.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-graph-partitioning/08-RESEARCH.md

# Plan 01 artifacts (will exist after wave 1)
@src/knowledge_graph/partition_index.py
@src/knowledge_graph/partition_manager.py

# Existing traversal to integrate with
@src/knowledge_graph/graph_traversal.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement boundary entity resolver</name>
  <files>src/knowledge_graph/boundary_resolver.py, tests/test_boundary_resolver.py</files>
  <action>
Create `src/knowledge_graph/boundary_resolver.py` with boundary entity identification and replication:

1. **BoundaryEntity dataclass** (from RESEARCH.md Pattern 3):
   ```python
   @dataclass
   class BoundaryEntity:
       entity_id: str
       home_partition: str
       replica_partitions: Set[str]
       edge_count_per_partition: Dict[str, int]
   ```

2. **BoundaryResolver class**:
   - `__init__(self, index: EntityPartitionIndex, manager: PartitionManager, replication_threshold: int = 10)`
   - `identify_boundary_entities() -> Dict[str, BoundaryEntity]`:
     - Iterate partition index to find entities in multiple partitions
     - Calculate edge counts per partition (from index or by loading partition)
     - Home partition = partition with highest edge count
     - Replica partitions = other partitions where edge_count >= replication_threshold
     - Return dict mapping entity_id to BoundaryEntity
   - `get_boundary_stats() -> Dict`:
     - Return total entities, boundary entities, avg replica count, replication ratio

3. **Key constraints**:
   - Do NOT actually copy entity data between partitions (just track in index)
   - Boundary identification is read-only analysis
   - Use partition_index.get_entity_partitions() for entity lookup
   - Store boundary metadata in memory (not persisted separately)

4. **Pitfall avoidance** (RESEARCH.md Pitfall 5: Boundary Entity Explosion):
   - Log warning if replication ratio > 30% (too many boundaries)
   - Expose stats for monitoring

5. **Tests** in `tests/test_boundary_resolver.py`:
   - test_identify_no_boundaries: Graph with isolated partitions has no boundary entities
   - test_identify_boundary_entity: Entity in 2 partitions is identified as boundary
   - test_home_partition_is_highest_edge_count: Home is partition where entity has most edges
   - test_replication_threshold: Partitions below threshold excluded from replica set
   - test_boundary_stats: Stats accurately reflect boundary count and ratios
  </action>
  <verify>
```bash
cd /home/kondraki/personal/geopol && python -m pytest tests/test_boundary_resolver.py -v
```
All tests pass.
  </verify>
  <done>
BoundaryResolver identifies cross-partition entities, calculates home/replica assignments, provides boundary statistics.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement scatter-gather query router and unified interface</name>
  <files>src/knowledge_graph/cross_partition_query.py, src/knowledge_graph/partitioned_graph.py, tests/test_cross_partition_query.py, tests/test_partitioned_graph.py</files>
  <action>
**Part A: Create `src/knowledge_graph/cross_partition_query.py` with QueryRouter class**

1. **QueryRouter class** (from RESEARCH.md Pattern 4):
   - `__init__(self, manager: PartitionManager, index: EntityPartitionIndex, max_workers: int = 4)`
   - Use `concurrent.futures.ThreadPoolExecutor` for parallel queries
   - `execute_k_hop_query(entity_id, k, time_start, time_end) -> TraversalResult`:
     - Step 1: Get partitions containing entity from index
     - Step 2: Filter partitions by time range if specified
     - Step 3: Scatter - submit parallel queries to each partition
     - Step 4: Gather - collect results, merge into single TraversalResult
     - Merge: union of nodes, deduplicate edges by (u, v, key)
   - `_query_single_partition(partition_id, entity_id, k, time_start, time_end) -> TraversalResult`:
     - Load partition via manager
     - Create GraphTraversal for partition
     - Execute k_hop_neighborhood
     - Return result

2. **Result merging**:
   - Nodes: set union
   - Edges: deduplicate by (source, target, key) tuple
   - If same edge in multiple partitions (boundary), keep first encountered

**Part B: Create `src/knowledge_graph/partitioned_graph.py` with PartitionedTemporalGraph class**

1. **PartitionedTemporalGraph class**:
   - `__init__(self, partition_dir: Path, index_path: Path, max_cached: int = 4)`:
     - Create EntityPartitionIndex from index_path
     - Create PartitionManager with partition_dir and index
     - Create QueryRouter with manager and index
   - `k_hop_neighborhood(entity_id, k, time_start, time_end, ...) -> TraversalResult`:
     - Delegate to QueryRouter.execute_k_hop_query
     - Same signature as GraphTraversal.k_hop_neighborhood for drop-in compatibility
   - `bilateral_relations(entity1, entity2, time_start, time_end, ...) -> TraversalResult`:
     - Find partitions containing either entity
     - Query each, merge results
   - `get_stats() -> Dict`:
     - Return partition count, total nodes, total edges, cache stats

2. **Factory function**:
   - `load_partitioned_graph(partition_dir: Path) -> PartitionedTemporalGraph`
   - Assumes index at `{partition_dir}/partition_meta.db`

**Part C: Tests**

`tests/test_cross_partition_query.py`:
- test_scatter_gather_basic: Query entity in 2 partitions returns merged result
- test_parallel_execution: Multiple partitions queried concurrently (verify via timing)
- test_edge_deduplication: Same edge in 2 partitions appears once in result
- test_time_range_filtering: Only partitions in time range are queried
- test_entity_not_found: Entity not in any partition returns empty result

`tests/test_partitioned_graph.py`:
- **CRITICAL: test_query_correctness_vs_full_graph** (from RESEARCH.md verify_partition_query_correctness):
  - Create test graph with 100 nodes, 500 edges across 3 months
  - Partition into 3 time-window partitions
  - For 20 random entities, compare k_hop_neighborhood(k=2) results:
    - Run on full graph via GraphTraversal
    - Run on partitioned graph via PartitionedTemporalGraph
    - Assert node sets are equal
  - This directly validates SCALE-02 requirement
- test_bilateral_relations_across_partitions: Entities in different partitions have relations found
- test_drop_in_api_compatibility: PartitionedTemporalGraph has same method signatures as GraphTraversal
  </action>
  <verify>
```bash
cd /home/kondraki/personal/geopol && python -m pytest tests/test_cross_partition_query.py tests/test_partitioned_graph.py -v
```
All tests pass, especially test_query_correctness_vs_full_graph.
  </verify>
  <done>
QueryRouter implements scatter-gather. PartitionedTemporalGraph provides unified interface. Query correctness test proves equivalence with single-graph queries.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Run full test suite for all partitioning modules:
```bash
cd /home/kondraki/personal/geopol && python -m pytest tests/test_partition_index.py tests/test_partition_manager.py tests/test_boundary_resolver.py tests/test_cross_partition_query.py tests/test_partitioned_graph.py -v --tb=short
```

2. End-to-end correctness validation (SCALE-02):
```python
# Full correctness validation script
import random
import tempfile
from pathlib import Path
import networkx as nx
from datetime import datetime, timedelta

from src.knowledge_graph.partition_index import EntityPartitionIndex
from src.knowledge_graph.partition_manager import PartitionManager
from src.knowledge_graph.partitioned_graph import PartitionedTemporalGraph
from src.knowledge_graph.graph_traversal import GraphTraversal

# Generate test graph with temporal edges
g = nx.MultiDiGraph()
entities = [f"ENTITY_{i}" for i in range(100)]
base_date = datetime(2024, 1, 1)

for _ in range(500):
    src = random.choice(entities)
    tgt = random.choice(entities)
    if src != tgt:
        ts = base_date + timedelta(days=random.randint(0, 90))
        g.add_edge(src, tgt, timestamp=ts.isoformat(), confidence=random.random())

print(f"Test graph: {g.number_of_nodes()} nodes, {g.number_of_edges()} edges")

with tempfile.TemporaryDirectory() as tmpdir:
    partition_dir = Path(tmpdir) / "partitions"
    db_path = partition_dir / "partition_meta.db"

    # Partition the graph
    index = EntityPartitionIndex(db_path)
    manager = PartitionManager(partition_dir, index)
    partition_ids = manager.partition_graph(g, window_days=30)
    index.close()

    print(f"Created {len(partition_ids)} partitions")

    # Load partitioned graph
    partitioned = PartitionedTemporalGraph(partition_dir, db_path)

    # Compare query results
    full_traversal = GraphTraversal(g)
    sample_entities = random.sample(entities, 20)

    correct = 0
    for entity in sample_entities:
        full_result = full_traversal.k_hop_neighborhood(entity, k=2)
        partitioned_result = partitioned.k_hop_neighborhood(entity, k=2)

        if full_result.nodes == partitioned_result.nodes:
            correct += 1
        else:
            missing = full_result.nodes - partitioned_result.nodes
            extra = partitioned_result.nodes - full_result.nodes
            print(f"MISMATCH for {entity}: missing={len(missing)}, extra={len(extra)}")

    accuracy = correct / len(sample_entities)
    print(f"Query correctness: {correct}/{len(sample_entities)} ({accuracy:.1%})")

    if accuracy == 1.0:
        print("SUCCESS: 100% query correctness")
    else:
        print("FAILURE: Query results differ from full graph")
```

3. Performance validation (SCALE-01, within 2x):
```python
# Performance comparison
import time

# Time full graph queries
full_start = time.time()
for entity in sample_entities:
    full_traversal.k_hop_neighborhood(entity, k=2)
full_time = time.time() - full_start

# Time partitioned queries (cold cache)
partitioned = PartitionedTemporalGraph(partition_dir, db_path)  # Fresh instance
partitioned_start = time.time()
for entity in sample_entities:
    partitioned.k_hop_neighborhood(entity, k=2)
partitioned_time = time.time() - partitioned_start

ratio = partitioned_time / full_time
print(f"Full graph: {full_time:.3f}s, Partitioned: {partitioned_time:.3f}s, Ratio: {ratio:.2f}x")

if ratio <= 2.0:
    print("SUCCESS: Performance within 2x threshold")
else:
    print(f"WARNING: Performance degradation {ratio:.2f}x exceeds 2x threshold")
```
</verification>

<success_criteria>
- [ ] BoundaryResolver identifies cross-partition entities correctly
- [ ] QueryRouter implements parallel scatter-gather
- [ ] PartitionedTemporalGraph provides GraphTraversal-compatible API
- [ ] test_query_correctness_vs_full_graph achieves 100% accuracy
- [ ] All tests pass
- [ ] Performance ratio <= 2x (warning acceptable, failure not)
</success_criteria>

<output>
After completion, create `.planning/phases/08-graph-partitioning/08-02-SUMMARY.md`
</output>
