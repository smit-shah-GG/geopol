---
phase: 11-tkg-predictor-replacement
plan: 03
type: execute
wave: 3
depends_on: ["11-02"]
files_modified:
  - src/settings.py
  - src/forecasting/tkg_predictor.py
  - src/training/scheduler.py
  - config/retraining.yaml
  - scripts/retrain_tkg.py
  - tests/test_tkg_backend_dispatch.py
autonomous: true

must_haves:
  truths:
    - "Setting TKG_BACKEND=tirgn in environment causes TKGPredictor to load TiRGN model instead of RE-GCN"
    - "Setting TKG_BACKEND=regcn (default) preserves existing RE-GCN behavior with zero changes"
    - "EnsemblePredictor.predict() works identically regardless of TKG_BACKEND value -- no downstream code changes"
    - "RetrainingScheduler.retrain() trains the model specified by TKG_BACKEND (tirgn or regcn)"
    - "Weekly automated retraining via scripts/retrain_tkg.py respects TKG_BACKEND and produces correct checkpoint format"
    - "TiRGN checkpoint .json metadata contains model_type='tirgn', enabling load-time validation"
    - "Attempting to load a TiRGN checkpoint with TKG_BACKEND=regcn (or vice versa) logs an error and falls back to baseline"
  artifacts:
    - path: "src/settings.py"
      provides: "tkg_backend setting (Literal['tirgn', 'regcn'], default='regcn')"
      contains: "tkg_backend"
    - path: "src/forecasting/tkg_predictor.py"
      provides: "Backend dispatch logic in TKGPredictor.__init__ loading TiRGN or RE-GCN based on config"
      contains: "tirgn"
    - path: "src/training/scheduler.py"
      provides: "Model-agnostic _train_new_model dispatching to train_tirgn or train_regcn based on TKG_BACKEND"
      contains: "tirgn"
    - path: "config/retraining.yaml"
      provides: "TiRGN-specific hyperparameters (history_rate, history_window, patience) alongside existing RE-GCN config"
      contains: "history_rate"
    - path: "tests/test_tkg_backend_dispatch.py"
      provides: "Integration tests for backend dispatch, config-only swap, and scheduler model selection"
      min_lines: 80
  key_links:
    - from: "src/settings.py"
      to: "src/forecasting/tkg_predictor.py"
      via: "Settings.tkg_backend read during TKGPredictor initialization"
      pattern: "get_settings.*tkg_backend"
    - from: "src/forecasting/tkg_predictor.py"
      to: "src/training/models/tirgn_jax.py"
      via: "Conditional import and instantiation of TiRGN model when backend=tirgn"
      pattern: "create_tirgn_model|TiRGN"
    - from: "src/training/scheduler.py"
      to: "src/training/train_tirgn.py"
      via: "Dispatches to train_tirgn() when TKG_BACKEND=tirgn"
      pattern: "train_tirgn"
    - from: "scripts/retrain_tkg.py"
      to: "src/settings.py"
      via: "Reads TKG_BACKEND to determine which model to retrain"
      pattern: "tkg_backend"
---

<objective>
Wire TiRGN into the production pipeline as a config-selectable backend behind the existing TKGPredictor interface, and make the retraining scheduler model-agnostic. After this plan, switching from RE-GCN to TiRGN requires only setting `TKG_BACKEND=tirgn` in the environment -- no code changes to EnsemblePredictor, calibration, daily pipeline, or API routes.

Purpose: This is the integration plan that delivers the "config-only swap" promise from success criterion #3. Without this, TiRGN exists in isolation and cannot be used for production forecasts or automated retraining.

Output: Modified TKGPredictor with backend dispatch, model-agnostic scheduler, updated retraining config, and integration tests proving the swap is transparent to downstream consumers.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-tkg-predictor-replacement/11-CONTEXT.md
@.planning/phases/11-tkg-predictor-replacement/11-RESEARCH.md
@.planning/phases/11-tkg-predictor-replacement/11-01-SUMMARY.md
@.planning/phases/11-tkg-predictor-replacement/11-02-SUMMARY.md
@src/settings.py
@src/forecasting/tkg_predictor.py
@src/forecasting/ensemble_predictor.py
@src/training/scheduler.py
@config/retraining.yaml
@scripts/retrain_tkg.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Settings, TKGPredictor backend dispatch, and checkpoint loading</name>
  <files>
    src/settings.py
    src/forecasting/tkg_predictor.py
  </files>
  <action>
  **src/settings.py**:

  Add TKG backend setting:
  ```python
  # -- TKG Model --
  tkg_backend: Literal["tirgn", "regcn"] = "regcn"
  ```

  This is an envvar: `TKG_BACKEND=tirgn` or `TKG_BACKEND=regcn`. Default is "regcn" to preserve backward compatibility. Requires process restart to take effect (per CONTEXT.md: "Config-only swap â€” requires process restart, no per-request model selection").

  **src/forecasting/tkg_predictor.py**:

  Modify TKGPredictor to support backend dispatch. The key constraint: EnsemblePredictor calls `self.tkg_predictor.predict_future_events()` and `self.tkg_predictor.validate_scenario_event()`. These interfaces must remain unchanged regardless of backend.

  1. Update `DEFAULT_MODEL_PATH` to be backend-aware:
     ```python
     @property
     def default_model_path(self) -> Path:
         backend = get_settings().tkg_backend
         if backend == "tirgn":
             return Path("models/tkg/tirgn_trained.npz")
         return Path("models/tkg/regcn_trained.pt")
     ```

  2. Update `__init__()`:
     - Import `get_settings` from `src.settings`.
     - Read `settings.tkg_backend`.
     - If `tkg_backend == "tirgn"`:
       a. Log info: "TKG backend: TiRGN".
       b. Set `self._backend = "tirgn"`.
       c. Do NOT instantiate REGCNWrapper -- instead, set `self._tirgn_model = None` (loaded lazily from checkpoint).
       d. Set `self.model = None` (REGCNWrapper is not used in TiRGN mode).
     - If `tkg_backend == "regcn"`:
       a. Existing behavior unchanged.
       b. Set `self._backend = "regcn"`.

  3. Update `_try_load_pretrained()`:
     - For tirgn backend: look for `models/tkg/tirgn_best.npz` and `models/tkg/tirgn_best.json`.
     - Load JSON metadata, verify `model_type == "tirgn"`. If mismatch, log error and return False.
     - Load model via `create_tirgn_model()` with config from metadata (creates fresh model with random weights).
     - **Explicit .npz restore algorithm** (mirrors the save path in `train_jax.save_checkpoint()`):
       1. Load the `.npz` file: `loaded = np.load(npz_path)`.
       2. Split the fresh model to get its abstract state: `state, graphdef = nnx.split(model)`.
       3. Get the state tree leaf paths: `paths_and_leaves = jax.tree_util.tree_leaves_with_path(state)`.
       4. The `.npz` keys are the `str(path)` of each leaf (this is how `save_checkpoint` writes them: `{str(k): v for k, v in jax.tree_util.tree_leaves_with_path(state_dict)}`).
       5. Reconstruct state by mapping `.npz` keys back to leaves: iterate `paths_and_leaves`, for each `(path, _leaf)`, look up `loaded[str(path)]`, producing a new tree with restored values.
       6. Merge the restored state back: `model = nnx.merge(graphdef, restored_state)`.
       7. If any key is missing from the `.npz` (shape mismatch, config mismatch), raise `ValueError` with the mismatched key -- do NOT silently use random weights.
     - Restore entity_to_id, relation_to_id from the JSON metadata file.
     - Set `self.trained = True`.
     - For regcn backend: existing behavior (loads .pt via PyTorch).

  4. Update `predict_future_events()`:
     - The interface stays the same (entity1, relation, entity2, k, apply_decay).
     - Internally, if `self._backend == "tirgn"`:
       a. Map entity/relation strings to IDs (existing `_entity_to_id`, `_relation_to_id` methods work as-is -- they use self.adapter).
       b. Build query triples as JAX arrays.
       c. Call `self._tirgn_model.predict(self._snapshots, query_triples)` to get scores.
       d. Convert scores to ranked predictions.
     - If `self._backend == "regcn"`: existing behavior via REGCNWrapper.

  5. **Do NOT modify**: `validate_scenario_event()`, `save()`, `load()`, `_apply_temporal_decay()`, `_entity_to_id()`, `_relation_to_id()` -- these work at the string level above the model and are backend-agnostic.

  **CRITICAL: The `self.adapter` (DataAdapter) is used by both backends for entity/relation string-to-ID mapping. It must be populated from the checkpoint regardless of backend.**
  </action>
  <verify>
  `python -c "from src.settings import Settings; s = Settings(tkg_backend='tirgn'); assert s.tkg_backend == 'tirgn'; print('settings OK')"` succeeds.
  `python -c "
import os
os.environ['TKG_BACKEND'] = 'regcn'
from src.forecasting.tkg_predictor import TKGPredictor
p = TKGPredictor(auto_load=False)
assert p._backend == 'regcn'
print('regcn dispatch OK')
"` succeeds (may show 'model not found' warnings, which is fine).
  </verify>
  <done>
  Settings has tkg_backend field. TKGPredictor dispatches to TiRGN or RE-GCN based on config. Checkpoint loading validates model_type metadata. Interface to EnsemblePredictor is unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Model-agnostic scheduler, retraining config, and integration tests</name>
  <files>
    src/training/scheduler.py
    config/retraining.yaml
    scripts/retrain_tkg.py
    tests/test_tkg_backend_dispatch.py
  </files>
  <action>
  **src/training/scheduler.py**:

  Make the retraining scheduler model-agnostic so it trains whichever model is configured.

  1. Update `_train_new_model()`:
     - Read `get_settings().tkg_backend`.
     - If `tkg_backend == "tirgn"`:
       a. Import `train_tirgn` from `src.training.train_tirgn`.
       b. Pull TiRGN-specific config from `self.config.get("model_tirgn", {})`.
       c. Call `train_tirgn(data_path, config, model_dir, ...)`.
       d. Returned checkpoint is `.npz` format.
     - If `tkg_backend == "regcn"`:
       a. Existing behavior (`train_regcn` from `scripts.train_tkg`).

  2. Update `_backup_current_model()`:
     - Backend-aware file patterns:
       - regcn: `regcn_trained.pt`, backup `regcn_backup_*.pt`
       - tirgn: `tirgn_best.npz` + `tirgn_best.json`, backup `tirgn_backup_*.npz` + `tirgn_backup_*.json`

  3. Update `_validate_new_model()`:
     - For tirgn: load `.json` metadata and compare MRR (not .pt via torch.load).
     - For regcn: existing behavior via torch.load.

  4. Update `_set_last_trained_time()`:
     - Include `model_type` in the JSON: `"model_type": settings.tkg_backend`.

  5. Update `_cleanup_old_backups()`:
     - Use backend-appropriate glob pattern.

  **config/retraining.yaml**:

  Add TiRGN-specific section alongside existing model config:

  ```yaml
  model_tirgn:
    epochs: 100
    batch_size: 1024
    embedding_dim: 200
    num_layers: 2
    learning_rate: 0.001
    history_rate: 0.3
    history_window: 50
    patience: 15
    logdir: runs/tirgn_retrain
  ```

  Keep existing `model:` section unchanged (it's the RE-GCN config).

  **scripts/retrain_tkg.py**:

  1. Add `--backend` CLI argument (default: from Settings, overridable for one-off runs).
  2. Log which backend is being retrained at startup.
  3. Pass backend to scheduler if overridden via CLI.

  **tests/test_tkg_backend_dispatch.py**:

  Integration tests for the full dispatch chain. Mock the actual model training/loading but test the wiring.

  1. `test_settings_tkg_backend_default`: Verify default is "regcn".
  2. `test_settings_tkg_backend_tirgn`: Set envvar, verify "tirgn".
  3. `test_tkg_predictor_backend_regcn`: Create TKGPredictor with regcn backend, verify self._backend == "regcn" and self.model is REGCNWrapper instance.
  4. `test_tkg_predictor_backend_tirgn`: Create TKGPredictor with tirgn backend (auto_load=False), verify self._backend == "tirgn" and self.model is None (no REGCNWrapper).
  5. `test_scheduler_dispatches_tirgn`: Mock train_tirgn, set backend=tirgn, call scheduler._train_new_model(), verify train_tirgn was called (not train_regcn).
  6. `test_scheduler_dispatches_regcn`: Mock train_regcn, set backend=regcn, call scheduler._train_new_model(), verify train_regcn was called.
  7. `test_ensemble_predictor_agnostic`: Create EnsemblePredictor with TKGPredictor(backend=tirgn, auto_load=False). Verify predict() gracefully handles untrained TKG (falls back to LLM-only).
  8. `test_checkpoint_model_type_validation`: Create a mock checkpoint with model_type="regcn", attempt to load with tirgn backend, verify it logs error and returns False.
  9. `test_retrain_script_help`: Verify `scripts/retrain_tkg.py --help` runs without error and shows --backend argument.

  Use `unittest.mock.patch.dict(os.environ, {"TKG_BACKEND": "tirgn"})` for environment manipulation in tests. Use `monkeypatch` if using pytest fixtures.
  </action>
  <verify>
  `python -c "
import os
os.environ['TKG_BACKEND'] = 'tirgn'
from src.training.scheduler import RetrainingScheduler
s = RetrainingScheduler()
print('scheduler OK with tirgn backend')
"` succeeds (may warn about missing config, which is fine).
  `python scripts/retrain_tkg.py --help` shows --backend argument.
  `uv run pytest tests/test_tkg_backend_dispatch.py -v` -- all tests pass.
  </verify>
  <done>
  Scheduler dispatches to correct training function based on TKG_BACKEND. Config includes TiRGN hyperparameters. Retrain script accepts --backend override. Integration tests verify the full dispatch chain from settings through predictor, scheduler, and ensemble. Swapping backend requires only an envvar change -- zero downstream code modifications. Requirements TKG-05 (weekly automated retraining) and success criterion #3 (config-only swap) are covered.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from src.settings import Settings; s = Settings(tkg_backend='tirgn'); assert s.tkg_backend == 'tirgn'"` -- settings work.
2. `python -c "import os; os.environ['TKG_BACKEND']='regcn'; from src.forecasting.tkg_predictor import TKGPredictor; p = TKGPredictor(auto_load=False); assert p._backend == 'regcn'"` -- regcn dispatch works.
3. `python scripts/retrain_tkg.py --help` -- shows --backend argument.
4. `uv run pytest tests/test_tkg_backend_dispatch.py -v` -- all 9 tests pass.
5. Verify no modifications to `src/forecasting/ensemble_predictor.py` (it must NOT be in files_modified -- this proves config-only swap).
6. `grep -r "tkg_backend" src/` shows settings.py and tkg_predictor.py and scheduler.py only.
</verification>

<success_criteria>
- TKG_BACKEND envvar controls which model is loaded and trained with zero changes to EnsemblePredictor or API routes.
- RE-GCN remains the default backend (backward compatible).
- Scheduler trains the correct model type and saves backend-appropriate checkpoints.
- Checkpoint model_type metadata prevents cross-loading (tirgn checkpoint with regcn backend or vice versa).
- Integration tests prove the dispatch chain works end-to-end.
- Requirements TKG-02 (protocol abstraction verified via dispatch), TKG-05 (scheduler works with TiRGN), and all 4 success criteria are covered.
</success_criteria>

<output>
After completion, create `.planning/phases/11-tkg-predictor-replacement/11-03-SUMMARY.md`
</output>
