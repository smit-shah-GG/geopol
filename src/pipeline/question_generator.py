"""
LLM-based forecast question generation from high-significance GDELT events.

Queries EventStorage for recent high-impact events (last 48h, sorted by
GoldsteinScale DESC, min_mentions >= 5), formats them into a structured
prompt, calls Gemini to generate yes/no forecast questions, and parses
the JSON response into GeneratedQuestion dataclass instances.

The generator caps output at Settings.gemini_daily_budget to prevent
budget blowout. Callers (DailyPipeline) should also check BudgetTracker
before invoking generation.
"""

from __future__ import annotations

import asyncio
import json
import logging
from dataclasses import dataclass
from datetime import datetime, timedelta

from src.database.storage import EventStorage
from src.forecasting.gemini_client import GeminiClient
from src.settings import get_settings

logger = logging.getLogger(__name__)


@dataclass
class GeneratedQuestion:
    """A forecast question generated by the LLM from GDELT events."""

    question: str
    country_iso: str
    horizon_days: int
    category: str  # conflict | diplomatic | economic


# Prompt template for question generation. The LLM receives a formatted
# list of high-significance events and returns structured JSON questions.
_QUESTION_GENERATION_PROMPT = """\
You are a geopolitical forecasting analyst. Given the following recent \
high-significance events from the GDELT database, generate {n_questions} \
binary (yes/no) forecast questions suitable for probabilistic prediction.

Each question must:
1. Be answerable with a probability between 0 and 1.
2. Have a clear resolution criterion.
3. Reference a specific country or actor.
4. Have a time horizon between 7 and 90 days.

EVENTS:
{events_text}

Return ONLY a JSON array of objects with these fields:
- "question": the yes/no forecast question (string)
- "country_iso": ISO 3166-1 alpha-2 country code (string, uppercase)
- "horizon_days": forecast horizon in days (integer, 7-90)
- "category": one of "conflict", "diplomatic", "economic" (string)

Example:
[
  {{
    "question": "Will Turkey conduct military operations in northern Syria within 30 days?",
    "country_iso": "SY",
    "horizon_days": 30,
    "category": "conflict"
  }}
]

Return ONLY the JSON array. No markdown, no explanation.
"""


class QuestionGenerator:
    """Generate forecast questions from recent GDELT events via Gemini.

    Attributes:
        gemini_client: GeminiClient for LLM question generation.
        event_storage: EventStorage for querying recent GDELT events.
    """

    def __init__(
        self,
        gemini_client: GeminiClient,
        event_storage: EventStorage,
    ) -> None:
        self.gemini_client = gemini_client
        self.event_storage = event_storage

    async def generate_questions(
        self,
        n_questions: int = 10,
        min_goldstein: float = 5.0,
    ) -> list[GeneratedQuestion]:
        """Generate forecast questions from recent high-significance events.

        Queries EventStorage for events from the last 48 hours with absolute
        GoldsteinScale >= min_goldstein and num_mentions >= 5. Formats them
        into a prompt, calls Gemini, and parses the JSON response.

        The result is capped at Settings.gemini_daily_budget to prevent
        budget blowout.

        Args:
            n_questions: Target number of questions to generate.
            min_goldstein: Minimum absolute GoldsteinScale for event inclusion.

        Returns:
            List of GeneratedQuestion instances, capped at the daily budget.
        """
        settings = get_settings()

        # Query recent high-significance events (last 48h)
        cutoff = datetime.now() - timedelta(hours=48)
        cutoff_str = cutoff.strftime("%Y-%m-%d")

        events = await asyncio.to_thread(
            self.event_storage.get_events,
            start_date=cutoff_str,
            min_mentions=5,
            limit=50,
        )

        if not events:
            logger.warning("No recent high-significance events found for question generation")
            return []

        # Filter by absolute GoldsteinScale (both very positive and very negative)
        filtered = [
            e for e in events
            if e.goldstein_scale is not None
            and abs(e.goldstein_scale) >= min_goldstein
        ]

        if not filtered:
            logger.warning(
                "No events with |GoldsteinScale| >= %.1f found (had %d events total)",
                min_goldstein,
                len(events),
            )
            # Fall back to all events if no high-significance ones
            filtered = events[:20]

        # Format events for the prompt
        events_text = self._format_events(filtered[:20])

        prompt = _QUESTION_GENERATION_PROMPT.format(
            n_questions=min(n_questions, settings.gemini_daily_budget),
            events_text=events_text,
        )

        # Call Gemini via asyncio.to_thread (GeminiClient is synchronous)
        try:
            response = await asyncio.to_thread(
                self.gemini_client.generate,
                prompt=prompt,
            )
        except Exception as exc:
            logger.error("Gemini question generation failed: %s", exc)
            return []

        # Parse JSON response
        questions = self._parse_response(response)

        # Cap at daily budget
        cap = settings.gemini_daily_budget
        if len(questions) > cap:
            logger.info(
                "Capping generated questions from %d to budget limit %d",
                len(questions),
                cap,
            )
            questions = questions[:cap]

        logger.info("Generated %d forecast questions from %d events", len(questions), len(filtered))
        return questions

    def _format_events(self, events: list) -> str:
        """Format GDELT events into a text block for the LLM prompt."""
        lines: list[str] = []
        for i, event in enumerate(events, 1):
            actors = []
            if event.actor1_code:
                actors.append(event.actor1_code)
            if event.actor2_code:
                actors.append(event.actor2_code)
            actor_str = " vs ".join(actors) if actors else "unknown"

            lines.append(
                f"{i}. [{event.event_date}] {actor_str} | "
                f"EventCode={event.event_code or 'N/A'} | "
                f"GoldsteinScale={event.goldstein_scale or 0:.1f} | "
                f"Mentions={event.num_mentions or 0} | "
                f"QuadClass={event.quad_class or 'N/A'}"
            )
            if event.title:
                lines.append(f"   Title: {event.title[:120]}")
        return "\n".join(lines)

    def _parse_response(self, response: str) -> list[GeneratedQuestion]:
        """Parse Gemini JSON response into GeneratedQuestion instances.

        Handles common LLM output quirks: markdown code fences, trailing
        commas, and partial JSON.
        """
        # Strip markdown code fences if present
        text = response.strip()
        if text.startswith("```"):
            # Remove opening fence (with optional language tag)
            first_newline = text.index("\n")
            text = text[first_newline + 1 :]
        if text.endswith("```"):
            text = text[:-3].rstrip()

        try:
            data = json.loads(text)
        except json.JSONDecodeError as exc:
            logger.error("Failed to parse Gemini response as JSON: %s", exc)
            logger.debug("Raw response: %s", text[:500])
            return []

        if not isinstance(data, list):
            logger.error("Gemini response is not a JSON array: %s", type(data).__name__)
            return []

        questions: list[GeneratedQuestion] = []
        for item in data:
            try:
                q = GeneratedQuestion(
                    question=str(item["question"]).strip(),
                    country_iso=str(item.get("country_iso", "XX")).upper()[:3],
                    horizon_days=int(item.get("horizon_days", 30)),
                    category=str(item.get("category", "conflict")).lower(),
                )
                # Basic validation
                if len(q.question) < 10:
                    continue
                if q.horizon_days < 1 or q.horizon_days > 365:
                    q.horizon_days = 30
                if q.category not in ("conflict", "diplomatic", "economic"):
                    q.category = "conflict"
                questions.append(q)
            except (KeyError, ValueError, TypeError) as exc:
                logger.warning("Skipping malformed question entry: %s", exc)
                continue

        return questions
